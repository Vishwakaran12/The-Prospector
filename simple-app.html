<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- CSP completely removed for Google Calendar API testing -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Prospector - Cyberpunk Interface</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --cyber-blue: #00ffff;
            --cyber-pink: #ff0080;
            --cyber-green: #00ff41;
            --cyber-orange: #ff6b00;
            --cyber-purple: #8b00ff;
            --dark-bg: #0a0a0a;
            --darker-bg: #050505;
        }

        body {
            font-family: 'Share Tech Mono', monospace;
            background: var(--dark-bg);
            color: var(--cyber-blue);
            overflow-x: hidden;
            min-height: 100vh;
            position: relative;
        }

        /* Animated Grid Background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridMove 20s linear infinite;
            z-index: -2;
        }

        @keyframes gridMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }

        /* Particle Effects */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: var(--cyber-blue);
            border-radius: 50%;
            animation: float 6s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { 
                transform: translateY(100vh) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) scale(1);
                opacity: 0;
            }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            position: relative;
        }

        .title {
            font-family: 'Orbitron', monospace;
            font-size: 3.5rem;
            font-weight: 900;
            background: linear-gradient(45deg, var(--cyber-blue), var(--cyber-pink), var(--cyber-green));
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            margin-bottom: 10px;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .subtitle {
            font-size: 1.2rem;
            color: var(--cyber-green);
            text-transform: uppercase;
            letter-spacing: 3px;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        .search-section {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(0, 255, 255, 0.1));
            border: 2px solid var(--cyber-blue);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }

        .search-section::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, var(--cyber-blue), var(--cyber-pink), var(--cyber-green), var(--cyber-orange));
            border-radius: 15px;
            z-index: -1;
            animation: borderGlow 3s linear infinite;
        }

        @keyframes borderGlow {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }

        .input-group {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .cyber-input {
            flex: 1;
            min-width: 250px;
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--cyber-blue);
            border-radius: 10px;
            color: var(--cyber-blue);
            font-family: 'Share Tech Mono', monospace;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .cyber-input:focus {
            outline: none;
            border-color: var(--cyber-pink);
            box-shadow: 0 0 20px rgba(255, 0, 128, 0.5);
            transform: translateY(-2px);
        }

        .cyber-button {
            padding: 15px 30px;
            background: linear-gradient(45deg, var(--cyber-blue), var(--cyber-green));
            border: none;
            border-radius: 10px;
            color: black;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .cyber-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .cyber-button:hover::before {
            left: 100%;
        }

        .cyber-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 255, 255, 0.4);
        }

        .results-section {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--cyber-green);
            border-radius: 15px;
            padding: 30px;
            min-height: 300px;
        }

        .results-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.8rem;
            color: var(--cyber-green);
            margin-bottom: 20px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .result-item {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(255, 0, 128, 0.05));
            border: 1px solid var(--cyber-blue);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
            position: relative;
        }

        .result-item:hover {
            transform: translateX(10px);
            border-color: var(--cyber-pink);
            box-shadow: -5px 0 15px rgba(255, 0, 128, 0.3);
        }

        .result-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.2rem;
            color: var(--cyber-blue);
            margin-bottom: 10px;
        }

        .result-link {
            color: var(--cyber-green);
            text-decoration: none;
            word-break: break-all;
            transition: color 0.3s ease;
        }

        .result-link:hover {
            color: var(--cyber-pink);
            text-shadow: 0 0 5px rgba(255, 0, 128, 0.5);
            background: rgba(0, 255, 0, 0.2) !important;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 255, 0, 0.3);
        }

        .result-snippet {
            color: #ccc;
            margin-top: 10px;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .loading {
            text-align: center;
            font-size: 1.2rem;
            color: var(--cyber-orange);
            animation: loadingPulse 1.5s ease-in-out infinite;
        }

        @keyframes loadingPulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* Glitch Effect */
        .glitch {
            position: relative;
            animation: glitch 2s infinite;
        }

        @keyframes glitch {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
        }

        /* Burger Menu Styles */
        .burger-menu {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid var(--cyber-blue);
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .burger-menu:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 20px var(--cyber-blue);
        }

        .burger-line {
            width: 25px;
            height: 3px;
            background: var(--cyber-blue);
            margin: 5px 0;
            transition: 0.3s;
            border-radius: 2px;
        }

        .burger-menu.open .burger-line:nth-child(1) {
            transform: rotate(-45deg) translate(-5px, 6px);
        }

        .burger-menu.open .burger-line:nth-child(2) {
            opacity: 0;
        }

        .burger-menu.open .burger-line:nth-child(3) {
            transform: rotate(45deg) translate(-5px, -6px);
        }

        /* Sidebar Styles */
        .sidebar {
            position: fixed;
            left: -400px;
            top: 0;
            width: 400px;
            height: 100vh;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(0, 20, 40, 0.95));
            border-right: 2px solid var(--cyber-blue);
            transition: left 0.3s ease;
            z-index: 999;
            overflow-y: auto;
            padding: 80px 20px 20px 20px;
            backdrop-filter: blur(10px);
        }

        .sidebar.open {
            left: 0;
        }

        .sidebar-title {
            color: var(--cyber-blue);
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 20px;
            text-align: center;
            border-bottom: 2px solid var(--cyber-blue);
            padding-bottom: 10px;
        }

        .sidebar-section {
            margin-bottom: 30px;
        }

        .sidebar-section h3 {
            color: var(--cyber-orange);
            font-size: 1.1rem;
            margin-bottom: 15px;
            border-left: 3px solid var(--cyber-orange);
            padding-left: 10px;
        }

        .history-item {
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid var(--cyber-blue);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .history-item:hover {
            background: rgba(0, 255, 255, 0.1);
            transform: translateX(5px);
            border-color: var(--cyber-green);
        }

        /* Event Card Specific Styles */
        .event-card {
            transition: all 0.3s ease;
        }

        .event-card:hover {
            background: rgba(0, 255, 255, 0.15) !important;
            transform: translateX(5px) scale(1.02);
            border-color: var(--cyber-green) !important;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .star-btn {
            transition: all 0.3s ease !important;
            position: relative !important;
            z-index: 10 !important;
            display: inline-block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        .star-btn:hover {
            transform: scale(1.1) !important;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5) !important;
        }

        .star-btn.starred {
            background: var(--cyber-blue) !important;
            color: black !important;
            animation: starPulse 1.5s ease-in-out infinite alternate;
        }

        @keyframes starPulse {
            0% { box-shadow: 0 0 15px rgba(0, 255, 255, 0.5); }
            100% { box-shadow: 0 0 25px rgba(0, 255, 255, 0.8); }
        }

        /* Calendar Widget Styles - Enhanced for better readability */
        .calendar-day-header {
            background: linear-gradient(135deg, var(--cyber-blue), var(--cyber-purple));
            color: white;
            font-weight: bold;
            text-align: center;
            padding: 12px 8px;
            font-size: 0.9rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            border-radius: 6px 6px 0 0;
        }

        .calendar-day {
            min-height: 80px;
            border: 1px solid rgba(0, 255, 255, 0.2);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.2));
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            flex-direction: column;
            border-radius: 8px;
            margin: 2px;
            backdrop-filter: blur(5px);
        }

        .calendar-day:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(139, 0, 255, 0.1));
            border-color: var(--cyber-blue);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.2);
        }

        .calendar-day.today {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 255, 65, 0.1));
            border: 2px solid var(--cyber-green);
            font-weight: bold;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        .calendar-day.has-events {
            background: linear-gradient(135deg, rgba(0, 255, 65, 0.15), rgba(0, 255, 255, 0.1));
            border-color: var(--cyber-green);
            box-shadow: 0 0 8px rgba(0, 255, 65, 0.2);
        }

        .calendar-day.other-month {
            opacity: 0.3;
            cursor: default;
            background: rgba(0, 0, 0, 0.1);
        }

        .calendar-day-number {
            font-size: 1rem;
            font-weight: bold;
            color: var(--cyber-blue);
            margin-bottom: 4px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .calendar-event-banner {
            background: linear-gradient(45deg, var(--cyber-green), var(--cyber-blue));
            color: black;
            font-size: 0.65rem;
            padding: 2px 4px;
            margin: 1px 0;
            border-radius: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-weight: bold;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .calendar-event-item {
            background: linear-gradient(135deg, rgba(0, 255, 65, 0.1), rgba(0, 255, 255, 0.05));
            border: 1px solid var(--cyber-green);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 255, 65, 0.1);
            transition: all 0.3s ease;
        }

        .calendar-event-item:hover {
            border-color: var(--cyber-blue);
            box-shadow: 0 6px 20px rgba(0, 255, 255, 0.15);
            transform: translateY(-2px);
        }

        .calendar-event-title {
            color: var(--cyber-green);
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 1.1rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .calendar-event-time {
            color: var(--cyber-blue);
            font-size: 0.95rem;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .calendar-event-description {
            color: #ccc;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        /* Calendar Page - Softer, Eye-Friendly Styling */
        .calendar-section {
            background: rgba(15, 25, 40, 0.5);
            border: 1px solid rgba(0, 150, 200, 0.2);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            backdrop-filter: blur(3px);
        }

        .calendar-section h3 {
            margin-bottom: 15px;
            font-weight: normal;
            opacity: 0.9;
            color: rgba(0, 200, 255, 0.8);
        }

        .calendar-auth-status {
            background: rgba(0, 60, 100, 0.15);
            border: 1px solid rgba(0, 120, 180, 0.3);
            border-radius: 8px;
            padding: 15px;
            color: rgba(0, 180, 255, 0.8);
        }

        .calendar-history-item {
            background: rgba(20, 30, 50, 0.3);
            border: 1px solid rgba(80, 120, 180, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 12px;
            transition: all 0.3s ease;
        }

        .calendar-history-item:hover {
            background: rgba(25, 40, 65, 0.5);
            border-color: rgba(0, 200, 255, 0.3);
            transform: translateY(-1px);
        }

        .calendar-event-item-soft {
            background: rgba(30, 20, 50, 0.3);
            border: 1px solid rgba(200, 100, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 12px;
        }

        .calendar-button-soft {
            background: rgba(0, 80, 130, 0.3);
            border: 1px solid rgba(0, 120, 200, 0.4);
            color: rgba(0, 180, 255, 0.9);
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .calendar-button-soft:hover {
            background: rgba(0, 120, 180, 0.4);
            border-color: rgba(0, 180, 255, 0.6);
            color: white;
        }

        /* Analytics Section Styling */
        .analytics-section {
            background: rgba(20, 15, 30, 0.5);
            border: 1px solid rgba(120, 80, 200, 0.3);
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
        }

        .analytics-card {
            background: rgba(25, 20, 45, 0.4);
            border: 1px solid rgba(100, 70, 180, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
        }

        .analytics-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(80, 120, 200, 0.1);
        }

        .analytics-stat:last-child {
            border-bottom: none;
        }

        .event-status-button {
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            border: 1px solid;
            cursor: pointer;
            margin: 0 3px;
            transition: all 0.3s ease;
        }

        .status-attended {
            background: rgba(0, 200, 80, 0.15);
            border-color: rgba(0, 200, 80, 0.4);
            color: rgba(0, 220, 90, 0.9);
        }

        .status-absent {
            background: rgba(200, 80, 80, 0.15);
            border-color: rgba(200, 80, 80, 0.4);
            color: rgba(220, 90, 90, 0.9);
        }

        .status-wishlist {
            background: rgba(200, 150, 0, 0.15);
            border-color: rgba(200, 150, 0, 0.4);
            color: rgba(220, 170, 0, 0.9);
        }

        .status-unknown {
            background: rgba(120, 120, 120, 0.15);
            border-color: rgba(120, 120, 120, 0.4);
            color: rgba(140, 140, 140, 0.9);
        }

        .newsletter-preview {
            background: rgba(10, 25, 40, 0.6);
            border: 1px solid rgba(0, 150, 200, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-top: 15px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            color: rgba(200, 220, 255, 0.9);
        }

        .report-section {
            background: rgba(15, 30, 20, 0.5);
            border: 1px solid rgba(0, 200, 100, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
        }

        /* Enhanced calendar grid */
        #calendarGrid {
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0, 255, 255, 0.1);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.3), rgba(0, 20, 40, 0.2));
        }

        /* Month navigation buttons */
        .month-nav-btn {
            background: linear-gradient(45deg, var(--cyber-blue), var(--cyber-purple));
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.2);
        }

        .month-nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 255, 0.3);
            background: linear-gradient(45deg, var(--cyber-green), var(--cyber-blue));
        }

        .history-content {
            flex: 1;
            min-width: 0;
        }

        .history-query {
            color: var(--cyber-blue);
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .history-date {
            color: #888;
            font-size: 0.8rem;
        }

        .history-results {
            color: var(--cyber-green);
            font-size: 0.8rem;
            margin-top: 5px;
        }

        .delete-btn {
            background: rgba(255, 0, 100, 0.2);
            border: 1px solid var(--cyber-pink);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-left: 10px;
            flex-shrink: 0;
        }

        .delete-btn:hover {
            background: rgba(255, 0, 100, 0.4);
            transform: scale(1.1);
            box-shadow: 0 0 10px var(--cyber-pink);
        }

        .delete-btn:active {
            transform: scale(0.95);
        }

        .preview-btn {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid var(--cyber-blue);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            flex-shrink: 0;
            font-size: 0.8rem;
        }

        .preview-btn:hover {
            background: rgba(0, 255, 255, 0.4);
            transform: scale(1.1);
            box-shadow: 0 0 10px var(--cyber-blue);
        }

        /* Source link hover effect */
        .result-link:hover {
            background: rgba(0, 255, 0, 0.2) !important;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 255, 0, 0.3);
        }

        .preview-btn:active {
            transform: scale(0.95);
        }

        /* Preview Modal Styles */
        .preview-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .preview-modal.show {
            display: flex;
        }

        .preview-content {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            border: 2px solid var(--cyber-blue);
            border-radius: 15px;
            padding: 20px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--cyber-blue);
        }

        .preview-close {
            background: rgba(255, 0, 100, 0.2);
            border: 1px solid var(--cyber-pink);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: var(--cyber-pink);
            font-weight: bold;
        }

        .preview-close:hover {
            background: rgba(255, 0, 100, 0.4);
            transform: scale(1.1);
        }

        .preview-results {
            max-height: 60vh;
            overflow-y: auto;
        }

        .preview-result-item {
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border-left: 4px solid var(--cyber-green);
        }

        /* Mode Button Styles */
        .mode-button {
            position: relative;
            padding: 10px 14px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--cyber-blue);
            border-radius: 10px;
            color: var(--cyber-blue);
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            min-width: 95px;
            max-width: 120px;
            flex: 1;
        }

        .mode-button:hover {
            transform: translateY(-2px);
            border-color: var(--cyber-pink);
            box-shadow: 0 5px 15px rgba(255, 0, 128, 0.3);
        }

        .mode-button.active {
            background: linear-gradient(45deg, var(--cyber-blue), var(--cyber-green));
            color: black;
            border-color: var(--cyber-green);
            animation: modePulse 2s ease-in-out infinite;
        }

        @keyframes modePulse {
            0%, 100% { box-shadow: 0 0 5px var(--cyber-green); }
            50% { box-shadow: 0 0 20px var(--cyber-green), 0 0 30px var(--cyber-blue); }
        }

        .mode-badge {
            font-size: 0.6rem;
            font-weight: 400;
            color: var(--cyber-orange);
            background: rgba(0, 0, 0, 0.8);
            padding: 2px 5px;
            border-radius: 6px;
            border: 1px solid var(--cyber-orange);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100px;
        }

        .mode-button.active .mode-badge {
            color: var(--cyber-pink);
            border-color: var(--cyber-pink);
        }

        /* Search Mode Indicator */
        .mode-indicator {
            padding: 10px 15px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid var(--cyber-blue);
            border-radius: 8px;
            margin: 10px 0;
            transition: all 0.3s ease;
        }

        .mode-indicator.detecting {
            animation: detecting 1.5s ease-in-out infinite;
        }

        @keyframes detecting {
            0%, 100% { background: rgba(0, 255, 255, 0.1); }
            50% { background: rgba(255, 107, 0, 0.2); }
        }

        .sidebar-stats {
            background: rgba(255, 165, 0, 0.1);
            border: 1px solid var(--cyber-orange);
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            color: var(--cyber-orange);
            font-size: 0.9rem;
        }

        .clear-history-btn {
            background: linear-gradient(45deg, var(--cyber-pink), var(--cyber-orange));
            color: black;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            transition: all 0.3s ease;
        }

        .clear-history-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px var(--cyber-pink);
        }

        /* Overlay for mobile */
        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            z-index: 998;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .sidebar-overlay.open {
            opacity: 1;
            visibility: visible;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .sidebar {
                width: 320px;
                left: -320px;
            }
            
            .container {
                padding-left: 10px;
                padding-right: 10px;
            }
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.95), rgba(20, 0, 40, 0.95));
            border: 2px solid var(--cyber-blue);
            border-radius: 15px;
            padding: 30px;
            width: 90%;
            max-width: 450px;
            position: relative;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3), inset 0 0 30px rgba(0, 255, 255, 0.1);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .close {
            position: absolute;
            top: 15px;
            right: 20px;
            color: var(--cyber-pink);
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .close:hover {
            color: var(--cyber-orange);
            transform: scale(1.2);
            text-shadow: 0 0 10px var(--cyber-orange);
        }

        .cyber-input {
            width: 100%;
            padding: 12px 15px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--cyber-blue);
            border-radius: 8px;
            color: var(--text-color);
            font-family: 'Orbitron', monospace;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            box-sizing: border-box;
        }

        .cyber-input:focus {
            outline: none;
            border-color: var(--cyber-green);
            box-shadow: 0 0 15px rgba(0, 255, 128, 0.3);
            background: rgba(0, 255, 128, 0.05);
        }

        .cyber-input:invalid {
            border-color: var(--cyber-pink);
        }

        .cyber-input::placeholder {
            color: #888;
        }
    </style>
</head>
<body>
    <!-- Burger Menu -->
    <div class="burger-menu" onclick="toggleSidebar()">
        <div class="burger-line"></div>
        <div class="burger-line"></div>
        <div class="burger-line"></div>
    </div>

    <!-- Sidebar Overlay -->
    <div class="sidebar-overlay" onclick="closeSidebar()"></div>

    <!-- Sidebar -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-title">🕵️ SEARCH HISTORY</div>
        
        <div class="sidebar-section">
            <div class="sidebar-stats">
                <div class="stat-item">
                    <span>Total Searches:</span>
                    <span id="totalSearches">0</span>
                </div>
                <div class="stat-item">
                    <span>Events Found:</span>
                    <span id="totalEvents">0</span>
                </div>
                <div class="stat-item">
                    <span>News Found:</span>
                    <span id="totalNews">0</span>
                </div>
            </div>
        </div>

        <div class="sidebar-section">
            <h3>📝 Recent Searches</h3>
            <div id="searchHistory">
                <!-- Search history will be populated here -->
            </div>
        </div>

        <div class="sidebar-section">
            <h3>⭐ Quick Actions</h3>
            <button class="clear-history-btn" onclick="clearSearchHistory()">
                Clear History
            </button>
            <button id="openCalendarBtn" class="clear-history-btn" style="margin-top:10px; display:none;" onclick="openCalendarMode()">
                📅 Open Calendar
            </button>
            <button class="clear-history-btn" style="margin-top:10px;" onclick="openPersonalizedReport()">
                📊 My Analytics Report
            </button>
        </div>
    </div>

    <div class="particles" id="particles"></div>
    
    <div class="container">
        <header class="header">
            <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap;">
                <div>
                    <h1 class="title glitch">THE PROSPECTOR</h1>
                    <p class="subtitle">Community Event Discovery Network v3.0</p>
                </div>
                
                <!-- Authentication Section -->
                <div id="authSection" style="display: flex; gap: 10px; align-items: center;">
                    <!-- Login/Register buttons (shown when not authenticated) -->
                    <div id="guestControls" style="display: flex; gap: 10px;">
                        <button onclick="showLoginForm()" class="cyber-button" style="padding: 8px 15px; font-size: 0.9rem;">
                            🔐 Login
                        </button>
                        <button onclick="showRegisterForm()" class="cyber-button" style="padding: 8px 15px; font-size: 0.9rem; background: linear-gradient(45deg, var(--cyber-pink), var(--cyber-blue));">
                            👤 Register
                        </button>
                    </div>
                    
                    <!-- User info (shown when authenticated) -->
                    <div id="userControls" style="display: none; align-items: center; gap: 15px;">
                        <span id="userWelcome" style="color: var(--cyber-green); font-weight: bold;"></span>
                        <button onclick="showProfileForm()" class="cyber-button" style="padding: 8px 15px; font-size: 0.9rem;">
                            ⚙️ Profile
                        </button>
                        <button onclick="logout()" class="cyber-button" style="padding: 8px 15px; font-size: 0.9rem; background: linear-gradient(45deg, var(--cyber-pink), #ff4444);">
                            🚪 Logout
                        </button>
                    </div>
                </div>
            </div>
        </header>

        <!-- Intelligent Search Mode Selector -->
        <section class="search-section" style="margin-bottom: 20px;">
            <h2 class="results-title" style="margin-bottom: 20px;">🤖 Intelligent Search Modes</h2>
            
            <!-- Search Mode Selector -->
            <div class="input-group" style="justify-content: center; margin-bottom: 20px;">
                <div style="display: flex; gap: 8px; flex-wrap: nowrap; width: 100%; justify-content: space-between; max-width: 800px;">
                    <button onclick="setSearchMode('auto')" class="mode-button active" id="autoMode">
                        🤖 Auto
                        <span class="mode-badge">Smart</span>
                    </button>
                    <button onclick="setSearchMode('events')" class="mode-button" id="eventsMode">
                        📅 Events
                        <span class="mode-badge">Local</span>
                    </button>
                    <button onclick="setSearchMode('github')" class="mode-button" id="githubMode">
                        💻 Code
                        <span class="mode-badge">GitHub</span>
                    </button>
                    <button onclick="setSearchMode('reddit')" class="mode-button" id="redditMode">
                        💬 Community
                        <span class="mode-badge">Reddit</span>
                    </button>
                    <button onclick="setSearchMode('news')" class="mode-button" id="newsMode">
                        📰 News
                        <span class="mode-badge">Latest</span>
                    </button>
                    <button onclick="setSearchMode('social')" class="mode-button" id="socialMode">
                        🌐 Social
                        <span class="mode-badge">All</span>
                    </button>
                    <!-- Calendar mode intentionally removed from main modes; access via burger menu only -->
                </div>
            </div>

            <!-- Page Navigation -->
            <div class="input-group" style="justify-content: center; margin-bottom: 20px;">
                <div style="display: flex; gap: 15px; align-items: center;">
                    <button onclick="showSearchPage()" class="cyber-button" id="searchPageBtn" style="padding: 10px 20px; background: linear-gradient(45deg, var(--cyber-blue), var(--cyber-green));">
                        🔍 Search & Discovery
                    </button>
                    <button onclick="showCalendarPage()" class="cyber-button" id="calendarPageBtn" style="padding: 10px 20px; background: linear-gradient(45deg, #333, #555);">
                        📅 Calendar & Events
                    </button>
                </div>
            </div>
        </section>

        <!-- Search Page -->
        <div id="searchPage" style="display: block;">
            <section class="search-section">
            <!-- Universal Search Input -->
            <div class="input-group">
                <input type="text" id="universalSearchQuery" class="cyber-input" placeholder="Enter your search query - AI will detect the best mode..." required />
                <input type="text" id="universalLocationInput" class="cyber-input" placeholder="Location (for events mode)..." />
                <button onclick="performComprehensiveSearch()" class="cyber-button" id="searchButton">
                    🚀 Smart Search
                </button>
            </div>
            
            <!-- Mode Indicator -->
            <div class="input-group" style="justify-content: center;">
                <div id="modeIndicator" style="color: var(--cyber-green); text-align: center; font-size: 0.9rem;">
                    🤖 Auto Mode: AI will analyze your query and choose the best search strategy
                </div>
            </div>
        </section>

        <!-- News-specific options section -->
        <section class="search-section" id="newsSearchSection" style="display: none;">
            <h2 class="results-title" style="margin-bottom: 20px;">📰 News Search Options</h2>
            
            <!-- News Category Selection -->
            <div style="display: flex; gap: 10px; margin-bottom: 15px; align-items: center; flex-wrap: wrap;">
                <label style="color: var(--cyber-pink); font-weight: bold;">📰 Category:</label>
                <select id="newsCategory" style="padding: 8px; background: rgba(255, 20, 147, 0.1); border: 1px solid var(--cyber-pink); border-radius: 5px; color: white;">
                    <option value="">All News</option>
                    <option value="business">💼 Business</option>
                    <option value="technology">💻 Technology</option>
                    <option value="science">🔬 Science</option>
                    <option value="health">🏥 Health</option>
                    <option value="sports">⚽ Sports</option>
                    <option value="entertainment">🎬 Entertainment</option>
                    <option value="general">📋 General</option>
                </select>
                
                <label style="color: var(--cyber-orange); margin-left: 15px; font-weight: bold;">📅 Time:</label>
                <select id="newsTimeframe" style="padding: 8px; background: rgba(255, 165, 0, 0.1); border: 1px solid var(--cyber-orange); border-radius: 5px; color: white;">
                    <option value="today">Today</option>
                    <option value="week">This Week</option>
                    <option value="month">This Month</option>
                    <option value="">All Time</option>
                </select>
                
                <label style="color: var(--cyber-green); margin-left: 15px; font-weight: bold;">🌍 Source:</label>
                <select id="newsSource" style="padding: 8px; background: rgba(0, 255, 0, 0.1); border: 1px solid var(--cyber-green); border-radius: 5px; color: white;">
                    <option value="">All Sources</option>
                    <option value="bbc-news">BBC News</option>
                    <option value="cnn">CNN</option>
                    <option value="reuters">Reuters</option>
                    <option value="associated-press">Associated Press</option>
                    <option value="techcrunch">TechCrunch</option>
                    <option value="the-verge">The Verge</option>
                </select>
            </div>
        </section>

        <section class="search-section" id="oldEventSearchSection" style="display: none;">
            <h2 class="results-title" id="eventSectionTitle" style="margin-bottom: 20px;">🎪 Advanced Event Search Options</h2>
            <!-- Tab Navigation -->
            <div style="display: flex; margin-bottom: 20px; border-bottom: 2px solid var(--cyber-blue);">
                <button id="eventsTab" class="tab-button" onclick="switchTab('events')" style="flex: 1; padding: 12px; background: var(--cyber-blue); color: black; border: none; font-weight: bold; cursor: pointer; border-radius: 5px 0 0 0;">
                    🎪 LIVE EVENTS
                </button>
                <button id="newsTab" class="tab-button" onclick="switchTab('news')" style="flex: 1; padding: 12px; background: rgba(0, 255, 255, 0.2); color: var(--cyber-blue); border: none; cursor: pointer; border-radius: 0 5px 0 0;">
                    📰 EVENT NEWS
                </button>
            </div>

            <!-- Sorting & Filter Options -->
            <div style="display: flex; gap: 10px; margin-bottom: 15px; align-items: center; flex-wrap: wrap;">
                <label style="color: var(--cyber-orange); font-weight: bold;">🔀 Sort by:</label>
                <select id="sortBy" style="padding: 8px; background: rgba(255, 165, 0, 0.1); border: 1px solid var(--cyber-orange); border-radius: 5px; color: white;">
                    <option value="relevance">Relevance Score</option>
                    <option value="date">Date (Soonest First)</option>
                    <option value="popularity">Popularity</option>
                    <option value="source">Source Quality</option>
                    <option value="price">Price (Free First)</option>
                </select>
                
                <label style="color: var(--cyber-pink); margin-left: 15px; font-weight: bold;">🎯 Focus:</label>
                <select id="eventFocus" style="padding: 8px; background: rgba(255, 20, 147, 0.1); border: 1px solid var(--cyber-pink); border-radius: 5px; color: white;">
                    <option value="all">All Events</option>
                    <option value="today">Today Only</option>
                    <option value="free">Free Events</option>
                    <option value="ticketed">Paid Events</option>
                    <option value="nearby">Close to Location</option>
                </select>
            </div>

            <div class="input-group">
                <input type="text" id="locationInput" class="cyber-input" placeholder="Enter location (city, state, zip)..." required />
                <select id="genreSelect" class="cyber-input" style="min-width: 200px;">
                    <option value="">All Genres</option>
                    <option value="tech">Technology & Tech Meetups</option>
                    <option value="business">Business & Networking</option>
                    <option value="arts">Arts & Culture</option>
                    <option value="music">Music & Concerts</option>
                    <option value="sports">Sports & Fitness</option>
                    <option value="food">Food & Drink</option>
                    <option value="gaming">Gaming & Esports</option>
                    <option value="education">Education & Learning</option>
                    <option value="health">Health & Wellness</option>
                    <option value="social">Social & Community</option>
                    <option value="outdoor">Outdoor & Adventure</option>
                    <option value="creative">Creative & DIY</option>
                    <option value="professional">Professional Development</option>
                    <option value="charity">Volunteer & Charity</option>
                </select>
            </div>
            <div class="input-group">
                <select id="eventTypeSelect" class="cyber-input" style="min-width: 200px;">
                    <option value="">All Event Types</option>
                    <option value="meetup">Meetups & Groups</option>
                    <option value="workshop">Workshops & Classes</option>
                    <option value="conference">Conferences & Seminars</option>
                    <option value="networking">Networking Events</option>
                    <option value="social">Social Gatherings</option>
                    <option value="online">Online Events</option>
                    <option value="festival">Festivals & Fairs</option>
                    <option value="concert">Concerts & Shows</option>
                    <option value="sports">Sports Events</option>
                    <option value="volunteer">Volunteer Opportunities</option>
                </select>
                <select id="timeframeSelect" class="cyber-input" style="min-width: 150px;">
                    <option value="immediate">Happening Now</option>
                    <option value="tonight">Tonight</option>
                    <option value="upcoming">This Week</option>
                    <option value="general">Any Time</option>
                </select>
                <input type="number" id="radiusInput" class="cyber-input" placeholder="Radius (miles)" value="25" min="1" max="100" style="max-width: 120px;" />
            </div>
            <div class="input-group">
                <button onclick="searchEvents()" class="cyber-button">🔍 Find Events</button>
                <button onclick="loadNearbyEvents()" class="cyber-button" style="background: linear-gradient(45deg, var(--cyber-purple), var(--cyber-blue));">📍 Use Location</button>
                <button onclick="clearResults()" class="cyber-button" style="background: linear-gradient(45deg, var(--cyber-pink), var(--cyber-orange));">🗑️ Clear</button>
            </div>
        </section>

        <section class="results-section" id="mainResultsSection">
            <!-- Events Tab Content -->
            <div id="eventsContent" class="tab-content">
                <h2 class="results-title">🎪 Live Events & Happenings</h2>
                <div id="eventsResults">
                    <p style="text-align: center; color: #666;">Enter location and preferences to discover live events...</p>
                </div>
            </div>
            
            <!-- News Tab Content -->
            <div id="newsContent" class="tab-content" style="display: none;">
                <h2 class="results-title">📰 Event News & Announcements</h2>
                <div id="newsResults">
                    <p style="text-align: center; color: #666;">Event news and announcements will appear here...</p>
                </div>
            </div>
            
        <!-- Combined Results (fallback) -->
        <div id="results" style="display: none;">
            <p style="text-align: center; color: #666;">Search results will appear here...</p>
        </div>
    </section>
</div>

        </div>
        <!-- End Search Page -->

        <!-- Calendar Page -->
        <div id="calendarPage" style="display: none;">
            <section class="search-section">
                <h2 class="results-title" style="margin-bottom: 20px;">📅 Calendar & Event Management</h2>
                
                <!-- Calendar Authentication Status -->
                <div id="calendarAuthStatus" style="padding: 15px; margin-bottom: 20px; border: 1px solid var(--cyber-blue); border-radius: 10px; background: rgba(0, 255, 255, 0.05);">
                    <div style="color: var(--cyber-blue);">
                        📅 Sign in to Google to access your calendars
                    </div>
                </div>

                <!-- Sign In Button -->
                <div id="signInButton" style="text-align: center; margin-bottom: 20px;">
                    <button onclick="signInToGoogle()" class="cyber-button" 
                            style="padding: 15px 30px; font-size: 1.1rem; 
                                   background: linear-gradient(45deg, #4285f4, #34a853);">
                        🌐 Sign in with Google Calendar
                    </button>
                </div>

                <!-- Calendar List -->
                <div id="calendarList" style="display: none; margin-bottom: 20px;">
                    <h3 style="color: var(--cyber-green); margin-bottom: 15px;">📋 Your Calendars</h3>
                    <div id="calendarsContainer">
                        <div style="margin-bottom: 15px;">
                            <label style="color: var(--cyber-blue); font-weight: bold;">Select Calendar:</label>
                            <select id="calendarSelect" class="cyber-input" style="min-width: 200px; margin-left: 10px;">
                                <option value="">All Calendars</option>
                            </select>
                        </div>
                        <div style="display: flex; gap: 15px; margin-bottom: 15px; flex-wrap: wrap; align-items: center;">
                            <div>
                                <label style="color: var(--cyber-green); font-weight: bold;">📅 From:</label>
                                <input type="date" id="startDate" class="cyber-input">
                            </div>
                            <div>
                                <label style="color: var(--cyber-green); font-weight: bold;">📅 To:</label>
                                <input type="date" id="endDate" class="cyber-input">
                            </div>
                            <button onclick="loadCalendarEvents()" class="cyber-button">
                                🔍 Load Events
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Event Form -->
                <div id="eventForm" style="display: none; margin-bottom: 20px;">
                    <h3 style="color: var(--cyber-orange); margin-bottom: 15px;">➕ Add New Event</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <input type="text" id="eventTitle" placeholder="Event Title" class="cyber-input">
                        <input type="datetime-local" id="eventDateTime" class="cyber-input">
                        <input type="text" id="eventLocation" placeholder="Location (optional)" class="cyber-input">
                        <select id="eventCalendar" class="cyber-input">
                            <option value="">Select Calendar</option>
                        </select>
                    </div>
                    <!-- Hidden select for compatibility with existing functions -->
                    <select id="eventCalendarSelect" class="cyber-input" style="display: none;">
                        <option value="">Select Calendar</option>
                    </select>
                    <textarea id="eventDescription" placeholder="Event Description (optional)" class="cyber-input" style="height: 80px; margin-bottom: 15px;"></textarea>
                    <button onclick="addEvent()" class="cyber-button">🚀 Add Event</button>
                </div>

                <!-- Calendar Widget -->
                <div id="calendarWidget" style="display: none; margin-bottom: 20px;">
                    <div style="border: 1px solid var(--cyber-purple); border-radius: 10px; padding: 15px; background: rgba(139, 0, 255, 0.05);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <button onclick="changeMonth(-1)" class="cyber-button" style="padding: 8px 12px;">◀</button>
                            <h3 id="currentMonth" style="color: var(--cyber-purple); margin: 0;"></h3>
                            <button onclick="changeMonth(1)" class="cyber-button" style="padding: 8px 12px;">▶</button>
                        </div>
                        <div id="calendarGrid" style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 2px; margin-bottom: 15px;"></div>
                        <div id="selectedDayEvents" style="display: none; padding: 15px; background: rgba(0, 255, 255, 0.1); border-radius: 8px;"></div>
                    </div>
                </div>

                <!-- Saved Events from Search History -->
                <div id="savedEventsSection" class="calendar-section" style="margin-bottom: 20px;">
                    <h3 style="color: var(--cyber-pink); margin-bottom: 15px;">⭐ Events from Search History</h3>
                    <div id="savedEventsContainer" style="border: 1px solid rgba(255, 0, 128, 0.2); border-radius: 10px; padding: 15px; background: rgba(255, 0, 128, 0.03);">
                        <p style="text-align: center; color: #999;">No saved events from search history yet...</p>
                    </div>
                </div>

                <!-- Search History for Calendar -->
                <div id="calendarSearchHistory" class="calendar-section" style="margin-bottom: 20px;">
                    <h3 style="color: var(--cyber-orange); margin-bottom: 15px;">📋 Recent Search History</h3>
                    <div style="border: 1px solid rgba(255, 107, 0, 0.2); border-radius: 10px; padding: 15px; background: rgba(255, 107, 0, 0.03);">
                        <div id="calendarHistoryContainer">
                            <p style="text-align: center; color: #999;">Loading search history...</p>
                        </div>
                        <div style="text-align: center; margin-top: 15px;">
                            <button onclick="showAllHistoryForCalendar()" class="calendar-button-soft" style="padding: 8px 15px; font-size: 0.9rem;">
                                📚 View All History
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Calendar Results -->
                <div id="calendarResults" style="min-height: 200px;">
                    <p style="text-align: center; color: #666;">Connect to Google Calendar to view and manage your events...</p>
                </div>
            </section>
        </div>
        <!-- End Calendar Page -->

        <!-- Authentication Modals -->
<div id="authModal" class="modal" style="display: none;">
    <div class="modal-content">
        <span class="close" onclick="closeAuthModal()">&times;</span>
        
        <!-- Login Form -->
        <div id="loginForm" style="display: none;">
            <h2 style="color: var(--cyber-blue); text-align: center; margin-bottom: 20px;">🔐 Agent Login</h2>
            <form onsubmit="login(event)" style="display: flex; flex-direction: column; gap: 15px;">
                <input type="text" id="loginUsername" placeholder="Username or Email" class="cyber-input" required>
                <input type="password" id="loginPassword" placeholder="Password" class="cyber-input" required>
                <button type="submit" class="cyber-button">Access Network</button>
                <div style="text-align:center; margin-top:6px;">
                    <button type="button" onclick="signInToGoogle()" class="cyber-button" style="background: linear-gradient(45deg, #4285f4, #34a853);">
                        Sign in with Google
                    </button>
                </div>
                <p style="text-align: center; color: #888; margin: 10px 0;">
                    New agent? <a href="#" onclick="switchToRegister()" style="color: var(--cyber-green);">Register here</a>
                </p>
            </form>
        </div>
        
        <!-- Register Form -->
        <div id="registerForm" style="display: none;">
            <h2 style="color: var(--cyber-green); text-align: center; margin-bottom: 20px;">👤 Agent Registration</h2>
            <form onsubmit="register(event)" style="display: flex; flex-direction: column; gap: 15px;">
                <input type="text" id="regUsername" placeholder="Username" class="cyber-input" required>
                <input type="email" id="regEmail" placeholder="Email Address" class="cyber-input" required>
                <input type="password" id="regPassword" placeholder="Password (min 6 chars)" class="cyber-input" required minlength="6">
                <input type="text" id="regFirstName" placeholder="First Name (optional)" class="cyber-input">
                <input type="text" id="regLastName" placeholder="Last Name (optional)" class="cyber-input">
                <button type="submit" class="cyber-button">Join Network</button>
                <div style="text-align:center; margin-top:6px;">
                    <button type="button" onclick="signInToGoogle()" class="cyber-button" style="background: linear-gradient(45deg, #4285f4, #34a853);">
                        Register with Google
                    </button>
                </div>
                <p style="text-align: center; color: #888; margin: 10px 0;">
                    Already an agent? <a href="#" onclick="switchToLogin()" style="color: var(--cyber-blue);">Login here</a>
                </p>
            </form>
        </div>
        
        <!-- Profile Form -->
        <div id="profileForm" style="display: none;">
            <h2 style="color: var(--cyber-orange); text-align: center; margin-bottom: 20px;">⚙️ Agent Profile</h2>
            <form onsubmit="updateProfile(event)" style="display: flex; flex-direction: column; gap: 15px;">
                <input type="text" id="profileFirstName" placeholder="First Name" class="cyber-input">
                <input type="text" id="profileLastName" placeholder="Last Name" class="cyber-input">
                <input type="text" id="profileDefaultLocation" placeholder="Default Location" class="cyber-input">
                <label style="color: var(--cyber-blue); margin-top: 10px;">Email Notifications:</label>
                <label style="display: flex; align-items: center; gap: 10px; color: #ccc;">
                    <input type="checkbox" id="profileEmailNotifications" style="scale: 1.2;">
                    Receive email updates
                </label>
                <button type="submit" class="cyber-button">Update Profile</button>
                <button type="button" onclick="showChangePassword()" class="cyber-button" style="background: linear-gradient(45deg, var(--cyber-orange), var(--cyber-pink)); margin-top: 10px;">
                    Change Password
                </button>
            </form>
        </div>
        
        <!-- Change Password Form -->
        <div id="changePasswordForm" style="display: none;">
            <h2 style="color: var(--cyber-pink); text-align: center; margin-bottom: 20px;">🔒 Change Password</h2>
            <form onsubmit="changePassword(event)" style="display: flex; flex-direction: column; gap: 15px;">
                <input type="password" id="currentPassword" placeholder="Current Password" class="cyber-input" required>
                <input type="password" id="newPassword" placeholder="New Password (min 6 chars)" class="cyber-input" required minlength="6">
                <input type="password" id="confirmPassword" placeholder="Confirm New Password" class="cyber-input" required minlength="6">
                <button type="submit" class="cyber-button">Update Password</button>
                <button type="button" onclick="showProfileForm()" class="cyber-button" style="background: #666; margin-top: 10px;">
                    Back to Profile
                </button>
            </form>
        </div>
    </div>
</div>

<!-- Search Preview Modal -->
<div id="previewModal" class="preview-modal">
    <div class="preview-content">
        <div class="preview-header">
            <h2 style="color: var(--cyber-blue); margin: 0;">🔍 Search Preview</h2>
            <div class="preview-close" onclick="closePreviewModal()">×</div>
        </div>
        <div id="previewDetails" style="margin-bottom: 20px;">
            <!-- Search details will be loaded here -->
        </div>
        <div class="preview-results" id="previewResults">
            <!-- Search results will be loaded here -->
        </div>
    </div>
</div>

    <script>
        // GitHub, Reddit, and Google Calendar API Configuration
        const API_CONFIG = {
            github: {
                token: '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',
                baseUrl: 'https://api.github.com'
            },
            reddit: {
                clientId: '6WvFTgrgGLXjqOyXGRSlZQ',
                clientSecret: 'jb3MA8zQxBllZIVPV6PtqkFrut-m-g',
                userAgent: 'wild west prospector scraper v1.0',
                redirectUri: 'http://localhost:8080',
                baseUrl: 'https://www.reddit.com/api/v1'
            },
            googleCalendar: {
                apiKey: 'AIzaSyDet8FIQM8OnoPdhhVoR6_4NfuiKynBHoE',
                clientId: '1012494277929-nkdc974uqvstuoqmd9b41cuotn1cb8uq.apps.googleusercontent.com',
                discoveryDoc: 'https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest',
                scopes: 'https://www.googleapis.com/auth/calendar'
            }
        };

        // Enhanced GitHub API with robust error handling and retry logic
        async function searchGitHub(query, retries = 3) {
            // Use a local proxy in development to avoid CSP/CORS issues
            const useProxy = window.location && window.location.hostname === 'localhost';
            const endpoint = useProxy ? `/api/proxy/github/search?q=${encodeURIComponent(query)}&per_page=20` : `${API_CONFIG.github.baseUrl}/search/repositories?q=${encodeURIComponent(query)}&sort=stars&per_page=20`;

            for (let attempt = 0; attempt < retries; attempt++) {
                try {
                    const headers = useProxy ? { 'Accept': 'application/vnd.github.v3+json' } : {
                        'Authorization': `token ${API_CONFIG.github.token}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'User-Agent': 'The-Prospector-App',
                        'X-GitHub-Api-Version': '2022-11-28'
                    };

                    const response = await fetch(endpoint, { headers });

                    if (response.status === 403) {
                        const resetTime = response.headers.get('X-RateLimit-Reset');
                        if (resetTime) {
                            const waitTime = (parseInt(resetTime) * 1000) - Date.now();
                            if (waitTime > 0 && waitTime < 60000) {
                                console.log(`Rate limited, waiting ${waitTime}ms`);
                                await new Promise(resolve => setTimeout(resolve, waitTime));
                                continue;
                            }
                        }
                    }

                    if (!response.ok) {
                        throw new Error(`GitHub API Error: ${response.status} - ${response.statusText}`);
                    }

                    const data = await response.json();
                    console.log('GitHub API success:', data.total_count, 'repositories found');
                    return data;

                } catch (error) {
                    console.error(`GitHub attempt ${attempt + 1} failed:`, error);
                    if (attempt === retries - 1) {
                        throw error;
                    }
                    await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));
                }
            }
        }

        // ========== GOOGLE CALENDAR API INTEGRATION ==========
        
        let isGoogleApiLoaded = false;
        let isGoogleSignedIn = false;
        let isInitializing = false;
        let googleCalendars = [];
        let accessToken = null;
        let calendarWindowOpened = false;

        // Persistent Google auth functions
        function saveGoogleAuthState(token) {
            if (token) {
                localStorage.setItem('googleAccessToken', token);
                localStorage.setItem('googleSignedIn', 'true');
                localStorage.setItem('googleAuthTime', Date.now().toString());
            }
        }

        function loadGoogleAuthState() {
            const token = localStorage.getItem('googleAccessToken');
            const signedIn = localStorage.getItem('googleSignedIn') === 'true';
            const authTime = localStorage.getItem('googleAuthTime');
            
            // Check if token is not too old (24 hours)
            if (token && signedIn && authTime) {
                const timeElapsed = Date.now() - parseInt(authTime);
                const maxAge = 24 * 60 * 60 * 1000; // 24 hours
                
                if (timeElapsed < maxAge) {
                    accessToken = token;
                    isGoogleSignedIn = true;
                    
                    // Set the token in gapi if available
                    if (typeof gapi !== 'undefined' && gapi.client) {
                        gapi.client.setToken({access_token: accessToken});
                    }
                    
                    console.log('Restored Google auth session');
                    return true;
                }
            }
            
            // Clear expired auth
            clearGoogleAuthState();
            return false;
        }

        function clearGoogleAuthState() {
            localStorage.removeItem('googleAccessToken');
            localStorage.removeItem('googleSignedIn');
            localStorage.removeItem('googleAuthTime');
            accessToken = null;
            isGoogleSignedIn = false;
        }

        // Check if Google Calendar API is accessible and token is valid
        async function validateGoogleToken() {
            if (!isGoogleSignedIn || !accessToken) {
                return false;
            }
            
            try {
                // Try a simple API call to check token validity
                const response = await gapi.client.calendar.calendarList.list({
                    maxResults: 1
                });
                return true;
            } catch (error) {
                if (error.status === 401) {
                    console.log('Google token expired, clearing auth state');
                    clearGoogleAuthState();
                    updateCalendarAuthStatus();
                    return false;
                }
                // Other errors might be network issues, not auth issues
                console.warn('Google Calendar API error (not auth related):', error);
                return true; // Assume token is still valid
            }
        }

        // Initialize Google APIs with new Google Identity Services
        async function initializeGoogleApis() {
            if (isGoogleApiLoaded) {
                console.log('Google APIs already loaded');
                return;
            }
            
            if (isInitializing) {
                console.log('Google APIs already initializing, waiting...');
                // Wait for current initialization to complete
                while (isInitializing && !isGoogleApiLoaded) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                return;
            }

            isInitializing = true;

            try {
                // Validate API credentials
                if (!API_CONFIG.googleCalendar.apiKey || API_CONFIG.googleCalendar.apiKey === 'YOUR_GOOGLE_CALENDAR_API_KEY' || API_CONFIG.googleCalendar.apiKey === 'DISABLED_FOR_NOW') {
                    console.warn('Google Calendar API key not configured - Calendar features will be disabled');
                    return; // Exit early, don't initialize calendar API
                }
                
                if (!API_CONFIG.googleCalendar.clientId || API_CONFIG.googleCalendar.clientId === 'YOUR_GOOGLE_CLIENT_ID') {
                    throw new Error('Google Calendar Client ID not configured. Please add your Client ID to the configuration.');
                }

                // Wait for gapi to be available (it's loaded via script tag in head)
                if (typeof gapi === 'undefined') {
                    console.log('Waiting for gapi to be available...');
                    let attempts = 0;
                    while (typeof gapi === 'undefined' && attempts < 50) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        attempts++;
                    }
                    
                    if (typeof gapi === 'undefined') {
                        throw new Error('Google APIs failed to load. Check your internet connection.');
                    }
                }

                console.log('Initializing Google APIs...');

                // Load only the client library (not auth2 since it's not supported for new clients)
                await new Promise((resolve, reject) => {
                    if (!gapi || !gapi.load) return reject(new Error('gapi.load not available'));
                    gapi.load('client', {
                        callback: resolve,
                        onerror: reject
                    });
                });
                
                // Initialize the client with API key only
                await gapi.client.init({
                    apiKey: API_CONFIG.googleCalendar.apiKey,
                    discoveryDocs: [API_CONFIG.googleCalendar.discoveryDoc]
                });
                
                // Note: auth2 is not available for new client applications
                // Authentication will be handled by Google Identity Services
                
                isGoogleApiLoaded = true;
                console.log('Google APIs initialized successfully');
                
                await updateCalendarUI();
                
            } catch (error) {
                console.error('Error initializing Google APIs:', error);
                
                let errorMsg = 'Failed to initialize Google Calendar API. ';
                const errorMessage = error?.message || error?.error || error || 'Unknown error';
                
                if (typeof errorMessage === 'string') {
                    if (errorMessage.includes('API key not configured')) {
                        errorMsg = errorMessage;
                    } else if (errorMessage.includes('Client ID not configured')) {
                        errorMsg = errorMessage;
                    } else if (errorMessage.includes('script not loaded')) {
                        errorMsg += 'Google API scripts failed to load. Please check your internet connection.';
                    } else {
                        errorMsg += `Error: ${errorMessage}`;
                    }
                } else {
                    errorMsg += 'Please check your API credentials in Google Cloud Console.';
                }
                
                document.getElementById('calendarAuthStatus').innerHTML = `
                    <div style="color: var(--cyber-pink);">
                        ❌ ${errorMsg}
                        <br><small>Check console for more details.</small>
                    </div>
                `;
            } finally {
                isInitializing = false;
            }
        }

        // Sign in to Google using Google Identity Services (GIS) for Calendar access
        async function signInToGoogle() {
            try {
                if (!isGoogleApiLoaded) {
                    await initializeGoogleApis();
                }
                
                // Check if Google Identity Services is loaded
                if (typeof google === 'undefined' || !google.accounts) {
                    throw new Error('Google Identity Services not loaded');
                }
                
                // Use Google Identity Services (GIS) for OAuth
                return new Promise((resolve, reject) => {
                    const client = google.accounts.oauth2.initTokenClient({
                        client_id: API_CONFIG.googleCalendar.clientId,
                        scope: API_CONFIG.googleCalendar.scopes,
                        callback: async (response) => {
                            if (response.error) {
                                console.error('Google Sign-In error:', response.error);
                                document.getElementById('calendarAuthStatus').innerHTML = `
                                    <div style="color: var(--cyber-pink);">
                                        ❌ Sign-in failed: ${response.error}
                                    </div>
                                `;
                                reject(new Error(response.error));
                                return;
                            }

                            // Store the access token
                            accessToken = response.access_token;
                            isGoogleSignedIn = true;
                            
                            // Store auth state in localStorage
                            localStorage.setItem('googleAccessToken', accessToken);
                            localStorage.setItem('googleSignedIn', 'true');
                            localStorage.setItem('googleAuthTime', Date.now().toString());
                            
                            // Set the token in gapi
                            if (typeof gapi !== 'undefined' && gapi.client) {
                                gapi.client.setToken({access_token: accessToken});
                            }
                            
                            console.log('Google sign-in successful with GIS');
                            isGoogleSignedIn = true;
                            
                            // Try to get user info and authenticate with the main app
                            try {
                                // Get user profile info from Google
                                const userInfoResponse = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
                                    headers: {
                                        'Authorization': `Bearer ${accessToken}`
                                    }
                                });
                                
                                if (userInfoResponse.ok) {
                                    const userInfo = await userInfoResponse.json();
                                    console.log('📋 Got user info from Google:', userInfo);
                                    
                                    // Create a mock ID token for our server authentication
                                    const mockIdToken = btoa(JSON.stringify({
                                        sub: userInfo.id,
                                        email: userInfo.email,
                                        name: userInfo.name,
                                        given_name: userInfo.given_name,
                                        family_name: userInfo.family_name,
                                        picture: userInfo.picture
                                    }));
                                    
                                    console.log('🔑 Created mock token, sending to server...');
                                    
                                    // Send to our server for authentication - try login first
                                    console.log('🚀 Sending Google auth to server (login attempt)...');
                                    let authResponse = await fetch('/api/auth/google', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        credentials: 'include',
                                        body: JSON.stringify({ idToken: mockIdToken, mode: 'login' })
                                    });
                                    
                                    // If user not found, try register mode
                                    if (authResponse.status === 404) {
                                        console.log('🔄 User not found, trying register mode...');
                                        authResponse = await fetch('/api/auth/google', {
                                            method: 'POST',
                                            headers: { 'Content-Type': 'application/json' },
                                            credentials: 'include',
                                            body: JSON.stringify({ idToken: mockIdToken, mode: 'register' })
                                        });
                                    }
                                    
                                    console.log('📡 Server auth response status:', authResponse.status);
                                    
                                    if (authResponse.ok) {
                                        const authData = await authResponse.json();
                                        console.log('✅ Server authentication successful:', authData);
                                        if (authData.user) {
                                            currentUser = authData.user;
                                            updateUIForAuthenticatedUser();
                                            closeAuthModal(); // Close the login modal
                                            showNotification('🎉 Signed in with Google successfully!', 'success');
                                        }
                                    } else {
                                        const errorData = await authResponse.text();
                                        console.error('❌ Server authentication failed:', authResponse.status, errorData);
                                        showNotification('⚠️ Google sign-in successful, but server session failed', 'warning');
                                    }
                                } else {
                                    console.warn('Could not get user info from Google API');
                                }
                            } catch (error) {
                                console.error('❌ Could not authenticate with main app:', error);
                                showNotification('⚠️ Google Calendar connected, but server authentication failed', 'warning');
                            }
                            
                            await updateCalendarUI();
                            await loadGoogleCalendars();
                            resolve(response);
                        }
                    });
                    
                    // Request access token
                    client.requestAccessToken();
                });
                
            } catch (error) {
                console.error('Google sign-in failed:', error);
                document.getElementById('calendarAuthStatus').innerHTML = `
                    <div style="color: var(--cyber-pink);">
                        ❌ Sign-in failed: ${error.message}
                    </div>
                `;
            }
        }

        function escapeHtml(str) {
            if (!str) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        // Sign out from Google
        async function signOutFromGoogle() {
            try {
                // Clear the access token and auth state
                accessToken = null;
                isGoogleSignedIn = false;
                googleCalendars = [];
                
                // Clear localStorage
                clearGoogleAuthState();
                
                // Clear gapi token if available
                if (typeof gapi !== 'undefined' && gapi.client) {
                    gapi.client.setToken(null);
                }
                
                // Also sign out from the main app
                try {
                    await fetch('/api/auth/logout', {
                        method: 'POST',
                        credentials: 'include'
                    });
                    currentUser = null;
                    updateUIForGuestUser();
                } catch (error) {
                    console.warn('Could not sign out from main app:', error);
                }
                
                await updateCalendarUI();
                
                console.log('Google sign-out successful');
                
            } catch (error) {
                console.error('Google sign-out failed:', error);
            }
        }

        // Update Calendar Authentication Status
        function updateCalendarAuthStatus() {
            const authStatusDiv = document.getElementById('calendarAuthStatus');
            const signInButton = document.getElementById('signInButton');
            const signOutButton = document.getElementById('signOutButton');
            
            if (!authStatusDiv) return;
            
            if (isGoogleSignedIn) {
                authStatusDiv.innerHTML = `
                    <div style="color: var(--cyber-green);">
                        ✅ Connected to Google Calendar
                    </div>
                `;
                if (signInButton) signInButton.style.display = 'none';
                if (signOutButton) signOutButton.style.display = 'inline-block';
            } else {
                authStatusDiv.innerHTML = `
                    <div style="color: var(--cyber-blue);">
                        📅 Sign in to Google to access your calendars
                    </div>
                `;
                if (signInButton) signInButton.style.display = 'inline-block';
                if (signOutButton) signOutButton.style.display = 'none';
            }
        }

        // Update Calendar UI based on sign-in status
        async function updateCalendarUI() {
            const authStatusDiv = document.getElementById('calendarAuthStatus');
            const calendarListDiv = document.getElementById('calendarList');
            const eventFormDiv = document.getElementById('eventForm');
            const calendarWidgetDiv = document.getElementById('calendarWidget');
            
            if (!isGoogleApiLoaded) {
                authStatusDiv.innerHTML = `
                    <div style="color: var(--cyber-orange);">
                        🔄 Initializing Google Calendar API...
                    </div>
                `;
                return;
            }
            
            if (isGoogleSignedIn) {
                // With GIS, we don't have direct access to profile info
                // We can make a simple API call to get user info if needed
                authStatusDiv.innerHTML = `
                    <div style="color: var(--cyber-green);">
                        ✅ Signed in to Google Calendar
                        <button onclick="signOutFromGoogle()" class="cyber-button" 
                                style="margin-left: 10px; padding: 5px 15px; font-size: 0.8rem; 
                                       background: linear-gradient(45deg, #5c1a4f, #752d6a); 
                                       border: 1px solid #ff00aa; color: #ff00aa;">
                            Sign Out
                        </button>
                    </div>
                `;
                
                calendarListDiv.style.display = 'block';
                eventFormDiv.style.display = 'block';
                calendarWidgetDiv.style.display = 'block';
                
                await loadGoogleCalendars();
                await loadCalendarEventsForWidget();
                
            } else {
                authStatusDiv.innerHTML = `
                    <div style="color: var(--cyber-blue);">
                        📅 Sign in to Google to access your calendars
                    </div>
                `;
                
                calendarListDiv.style.display = 'none';
                eventFormDiv.style.display = 'none';
                calendarWidgetDiv.style.display = 'none';
            }
        }

        // Load Google Calendars
        async function loadGoogleCalendars() {
            if (!isGoogleSignedIn || !accessToken) {
                console.warn('Cannot load calendars: not signed in or no access token');
                return;
            }

            try {
                // Ensure the token is set
                gapi.client.setToken({access_token: accessToken});
                
                const response = await gapi.client.calendar.calendarList.list();
                googleCalendars = response.result.items || [];
                
                const calendarSelect = document.getElementById('calendarSelect');
                const eventCalendarSelect = document.getElementById('eventCalendarSelect');
                const eventCalendar = document.getElementById('eventCalendar');
                
                if (calendarSelect) {
                    calendarSelect.innerHTML = '<option value="">All Calendars</option>';
                }
                if (eventCalendarSelect) {
                    eventCalendarSelect.innerHTML = '';
                }
                if (eventCalendar) {
                    eventCalendar.innerHTML = '<option value="">Select Calendar</option>';
                }
                
                googleCalendars.forEach(calendar => {
                    // For calendarSelect (calendar list)
                    if (calendarSelect) {
                        const option = document.createElement('option');
                        option.value = calendar.id;
                        option.textContent = calendar.summary;
                        calendarSelect.appendChild(option);
                    }
                    
                    // For eventCalendarSelect (compatibility)
                    if (eventCalendarSelect) {
                        const eventOption = document.createElement('option');
                        eventOption.value = calendar.id;
                        eventOption.textContent = calendar.summary;
                        eventCalendarSelect.appendChild(eventOption);
                    }
                    
                    // For eventCalendar (visible event form)
                    if (eventCalendar) {
                        const newEventOption = document.createElement('option');
                        newEventOption.value = calendar.id;
                        newEventOption.textContent = calendar.summary;
                        eventCalendar.appendChild(newEventOption);
                    }
                });
                
                console.log('Loaded calendars:', googleCalendars.length);
                
                // Load events for the first time
                await loadCalendarEvents();
                
            } catch (error) {
                console.error('Error loading calendars:', error);
                
                // Handle authentication errors
                if (error.status === 401 || error.result?.error?.code === 401) {
                    console.warn('Authentication expired, clearing auth state');
                    clearGoogleAuthState();
                    await updateCalendarUI();
                    return;
                }
                
                document.getElementById('calendarList').innerHTML = `
                    <div style="color: var(--cyber-pink);">
                        ❌ Error loading calendars: ${error.message || 'Authentication required'}
                        <br><small>Please sign in to Google Calendar again.</small>
                    </div>
                `;
            }
        }

        // Load Calendar Events
        async function loadCalendarEvents() {
            if (!isGoogleSignedIn) return;
            
            try {
                const calendarSelect = document.getElementById('calendarSelect');
                const selectedCalendar = calendarSelect ? calendarSelect.value : '';
                const eventsContainer = document.getElementById('calendarResults');
                
                if (!eventsContainer) {
                    console.error('Calendar results container not found');
                    return;
                }
                
                eventsContainer.innerHTML = '<div class="loading">📅 Loading events...</div>';
                
                const calendarsToLoad = selectedCalendar 
                    ? [googleCalendars.find(cal => cal.id === selectedCalendar)]
                    : googleCalendars.slice(0, 5); // Limit to first 5 calendars for performance
                
                let allEvents = [];
                
                for (const calendar of calendarsToLoad) {
                    if (!calendar) continue;
                    
                    const response = await gapi.client.calendar.events.list({
                        calendarId: calendar.id,
                        timeMin: new Date().toISOString(),
                        maxResults: 20,
                        singleEvents: true,
                        orderBy: 'startTime'
                    });
                    
                    const events = response.result.items || [];
                    events.forEach(event => {
                        event.calendarName = calendar.summary;
                        event.calendarColor = calendar.backgroundColor || '#4285f4';
                    });
                    
                    allEvents = allEvents.concat(events);
                }
                
                allEvents.sort((a, b) => {
                    const aDate = new Date(a.start.dateTime || a.start.date);
                    const bDate = new Date(b.start.dateTime || b.start.date);
                    return aDate - bDate;
                });
                
                displayCalendarEvents(allEvents);
                
            } catch (error) {
                console.error('Error loading events:', error);
                const eventsContainer = document.getElementById('calendarResults');
                if (eventsContainer) {
                    let errorMessage = error.message || 'Unknown error';
                    
                    // Handle specific error types
                    if (error.status === 401 || error.result?.error?.code === 401) {
                        errorMessage = 'Authentication expired. Please sign in again.';
                        isGoogleSignedIn = false;
                        localStorage.removeItem('googleCalendarAuth');
                        updateCalendarAuthStatus();
                    } else if (error.result?.error?.code === -1) {
                        errorMessage = 'Network connection error. Please check your internet connection.';
                    }
                    
                    eventsContainer.innerHTML = `
                        <div style="color: var(--cyber-pink);">
                            ❌ Error loading events: ${errorMessage}
                        </div>
                    `;
                }
            }
        }

        // Display Calendar Events
        function displayCalendarEvents(events, calendarId) {
            const container = document.getElementById('calendarResults');
            
            if (!container) {
                console.error('Calendar results container not found');
                return;
            }
            
            if (!events || events.length === 0) {
                container.innerHTML = '<div style="color: var(--cyber-orange);">📅 No upcoming events found</div>';
                return;
            }
            
            const eventsHtml = events.map(event => {
                const startDate = new Date(event.start.dateTime || event.start.date);
                const endDate = new Date(event.end.dateTime || event.end.date);
                const isAllDay = !event.start.dateTime;
                
                const timeString = isAllDay 
                    ? 'All Day'
                    : `${startDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })} - ${endDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
                
                const evId = event.id || (event.htmlLink || event.summary || startDate.toISOString());
                const evMeta = { 
                    title: event.summary, 
                    description: event.description, 
                    link: event.htmlLink,
                    eventDate: startDate.toISOString().split('T')[0], // YYYY-MM-DD format
                    eventTime: isAllDay ? null : startDate.toTimeString().split(' ')[0], // HH:MM:SS format
                    eventLocation: event.location,
                    source: 'Google Calendar'
                };
                const isStarred = isItemStarred(evId);
                return `
                    <div class="result-item" style="border-left: 4px solid ${event.calendarColor || '#4285f4'}; position: relative;">
                        <div style="position: absolute; top: 10px; right: 12px;">
                            <button class="star-btn ${isStarred ? 'starred' : ''}" onclick="toggleStar('${escapeForJS(evId)}', '${encodeURIComponent(JSON.stringify(evMeta))}')" title="⭐ Star and save to your personal calendar" style="padding:6px 8px; border-radius:6px; background: rgba(0,255,255,0.2) !important; border:1px solid var(--cyber-blue) !important; color: var(--cyber-blue) !important; font-weight: bold !important;">
                                ${isStarred ? '★ Starred' : '☆ Star'}
                            </button>
                        </div>
                        <div class="result-title" style="color: var(--cyber-blue);">
                            ${event.summary || 'Untitled Event'}
                        </div>
                        <div style="color: var(--cyber-green); font-size: 0.9rem; margin: 5px 0;">
                            📅 ${startDate.toLocaleDateString()} • ${timeString}
                        </div>
                        ${event.calendarName ? `<div style="color: var(--cyber-orange); font-size: 0.8rem;">📋 ${event.calendarName}</div>` : ''}
                        ${event.description ? `<div class="result-snippet">${event.description.substring(0, 150)}${event.description.length > 150 ? '...' : ''}</div>` : ''}
                        ${event.location ? `<div style="color: var(--cyber-pink); font-size: 0.9rem; margin-top: 5px;">📍 ${event.location}</div>` : ''}
                        ${event.htmlLink ? `<a href="${event.htmlLink}" target="_blank" class="result-link" style="display: inline-block; margin-top: 10px;">View in Google Calendar →</a>` : ''}
                    </div>
                `;
            }).join('');
            
            container.innerHTML = eventsHtml;
        }

        // Create Calendar Event
        async function createCalendarEvent() {
            if (!isGoogleSignedIn) {
                alert('Please sign in to Google Calendar first');
                return;
            }
            
            try {
                const calendarId = document.getElementById('eventCalendarSelect').value;
                const title = document.getElementById('eventTitle').value;
                const description = document.getElementById('eventDescription').value;
                const startDate = document.getElementById('eventStartDate').value;
                const startTime = document.getElementById('eventStartTime').value;
                const endDate = document.getElementById('eventEndDate').value;
                const endTime = document.getElementById('eventEndTime').value;
                const location = document.getElementById('eventLocation').value;
                
                if (!calendarId || !title || !startDate) {
                    alert('Please fill in required fields: Calendar, Title, and Start Date');
                    return;
                }
                
                const startDateTime = startTime 
                    ? `${startDate}T${startTime}:00`
                    : startDate;
                    
                const endDateTime = endDate && endTime 
                    ? `${endDate}T${endTime}:00`
                    : endDate || startDate;
                
                const event = {
                    summary: title,
                    description: description,
                    location: location,
                    start: startTime ? {
                        dateTime: startDateTime,
                        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                    } : {
                        date: startDate
                    },
                    end: (endDate && endTime) ? {
                        dateTime: endDateTime,
                        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                    } : {
                        date: endDate || startDate
                    }
                };
                
                const response = await gapi.client.calendar.events.insert({
                    calendarId: calendarId,
                    resource: event
                });
                
                console.log('Event created:', response.result);
                alert('Event created successfully!');
                
                // Clear form
                document.getElementById('eventTitle').value = '';
                document.getElementById('eventDescription').value = '';
                document.getElementById('eventStartDate').value = '';
                document.getElementById('eventStartTime').value = '';
                document.getElementById('eventEndDate').value = '';
                document.getElementById('eventEndTime').value = '';
                document.getElementById('eventLocation').value = '';
                
                // Reload events
                await loadCalendarEvents();
                await loadCalendarEventsForWidget();
                
            } catch (error) {
                console.error('Error creating event:', error);
                alert('Error creating event: ' + error.message);
            }
        }

        // Add event to Google Calendar from the form
        async function addEvent() {
            const title = document.getElementById('eventTitle').value.trim();
            const dateTime = document.getElementById('eventDateTime').value;
            const location = document.getElementById('eventLocation').value.trim();
            const description = document.getElementById('eventDescription').value.trim();
            const calendarId = document.getElementById('eventCalendar').value || document.getElementById('eventCalendarSelect').value;

            if (!title || !dateTime) {
                showNotification('❌ Please fill in event title and date/time', 'error');
                return;
            }

            if (!isGoogleSignedIn) {
                showNotification('❌ Please sign in to Google Calendar first', 'error');
                return;
            }

            try {
                const startDateTime = new Date(dateTime);
                const endDateTime = new Date(startDateTime.getTime() + 60 * 60 * 1000); // Default 1 hour duration

                const event = {
                    summary: title,
                    start: {
                        dateTime: startDateTime.toISOString(),
                        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                    },
                    end: {
                        dateTime: endDateTime.toISOString(),
                        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                    },
                    location: location || undefined,
                    description: description || undefined
                };

                const calendar = calendarId || 'primary';
                const response = await gapi.client.calendar.events.insert({
                    calendarId: calendar,
                    resource: event
                });

                if (response.result) {
                    showNotification('🎉 Event added successfully!', 'success');
                    
                    // Clear form
                    document.getElementById('eventTitle').value = '';
                    document.getElementById('eventDateTime').value = '';
                    document.getElementById('eventLocation').value = '';
                    document.getElementById('eventDescription').value = '';
                    
                    // Refresh calendar widget if visible
                    if (document.getElementById('calendarWidget').style.display !== 'none') {
                        await loadCalendarEventsForWidget();
                    }
                } else {
                    showNotification('❌ Failed to add event', 'error');
                }
            } catch (error) {
                console.error('Error adding event:', error);
                showNotification('❌ Error adding event: ' + error.message, 'error');
            }
        }

        // ========== CALENDAR WIDGET FUNCTIONS ==========
        
        let currentCalendarDate = new Date();
        let calendarEvents = [];
        
        // Initialize Calendar Widget
        function initializeCalendarWidget() {
            generateCalendar();
            loadCalendarEventsForWidget();
        }
        
        // Generate Calendar Grid
        function generateCalendar() {
            const year = currentCalendarDate.getFullYear();
            const month = currentCalendarDate.getMonth();
            
            // Update header
            document.getElementById('currentMonth').textContent = 
                new Date(year, month).toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            
            // Get first day of month and number of days
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const today = new Date();
            
            const calendarGrid = document.getElementById('calendarGrid');
            calendarGrid.innerHTML = '';
            
            // Add day headers
            const dayHeaders = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            dayHeaders.forEach(day => {
                const dayHeader = document.createElement('div');
                dayHeader.className = 'calendar-day-header';
                dayHeader.textContent = day;
                calendarGrid.appendChild(dayHeader);
            });
            
            // Add empty cells for days before month starts
            for (let i = 0; i < firstDay; i++) {
                const emptyDay = document.createElement('div');
                emptyDay.className = 'calendar-day other-month';
                calendarGrid.appendChild(emptyDay);
            }
            
            // Add days of the month
            for (let day = 1; day <= daysInMonth; day++) {
                const dayElement = document.createElement('div');
                dayElement.className = 'calendar-day';
                
                const currentDate = new Date(year, month, day);
                const isToday = currentDate.toDateString() === today.toDateString();
                
                if (isToday) {
                    dayElement.classList.add('today');
                }
                
                // Check if day has events
                const dayEvents = getEventsForDate(currentDate);
                if (dayEvents.length > 0) {
                    dayElement.classList.add('has-events');
                }
                
                dayElement.innerHTML = `
                    <div class="calendar-day-number">${day}</div>
                    ${dayEvents.slice(0, 2).map(event => 
                        `<div class="calendar-event-banner" title="${event.summary}">${event.summary}</div>`
                    ).join('')}
                    ${dayEvents.length > 2 ? `<div class="calendar-event-banner">+${dayEvents.length - 2} more</div>` : ''}
                `;
                
                dayElement.addEventListener('click', () => showEventsForDay(currentDate, dayEvents));
                
                calendarGrid.appendChild(dayElement);
            }
        }
        
        // Change Calendar Month
        function changeMonth(direction) {
            currentCalendarDate.setMonth(currentCalendarDate.getMonth() + direction);
            generateCalendar();
        }
        
        // Get Events for a Specific Date
        function getEventsForDate(date) {
            return calendarEvents.filter(event => {
                const eventDate = new Date(event.start.dateTime || event.start.date);
                return eventDate.toDateString() === date.toDateString();
            });
        }
        
        // Show Events for Selected Day
        function showEventsForDay(date, events) {
            const container = document.getElementById('selectedDayEvents');
            
            container.innerHTML = `
                <h4 style="color: var(--cyber-blue); margin-bottom: 15px;">
                    Events for ${date.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}
                </h4>
                ${events.length === 0 ? 
                    '<div style="color: var(--cyber-orange);">No events scheduled</div>' :
                    events.map(event => {
                        const startDate = new Date(event.start.dateTime || event.start.date);
                        const endDate = new Date(event.end.dateTime || event.end.date);
                        const isAllDay = !event.start.dateTime;
                        
                        const timeString = isAllDay 
                            ? 'All Day'
                            : `${startDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })} - ${endDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
                        
                        return `
                            <div class="calendar-event-item">
                                <div class="calendar-event-title">${event.summary || 'Untitled Event'}</div>
                                <div class="calendar-event-time">${timeString}</div>
                                ${event.description ? `<div class="calendar-event-description">${event.description}</div>` : ''}
                                ${event.location ? `<div style="color: var(--cyber-pink); font-size: 0.8rem;">📍 ${event.location}</div>` : ''}
                            </div>
                        `;
                    }).join('')
                }
            `;
        }
        
        // Load Calendar Events for Widget
        async function loadCalendarEventsForWidget() {
            if (!isGoogleSignedIn || !isGoogleApiLoaded) return;
            
            // Validate token before making API calls
            const isTokenValid = await validateGoogleToken();
            if (!isTokenValid) {
                console.log('Google token invalid, skipping calendar widget refresh');
                return;
            }
            
            try {
                // Check if we need to refresh the token
                if (!gapi.client || !gapi.client.calendar) {
                    console.log('Google Calendar API client not ready, skipping widget refresh');
                    return;
                }

                let allEvents = [];
                
                for (const calendar of googleCalendars.slice(0, 5)) {
                    try {
                        const response = await gapi.client.calendar.events.list({
                            calendarId: calendar.id,
                            timeMin: new Date(currentCalendarDate.getFullYear(), currentCalendarDate.getMonth(), 1).toISOString(),
                            timeMax: new Date(currentCalendarDate.getFullYear(), currentCalendarDate.getMonth() + 1, 0, 23, 59, 59).toISOString(),
                            singleEvents: true,
                            orderBy: 'startTime'
                        });
                        
                        const events = response.result.items || [];
                        events.forEach(event => {
                            event.calendarName = calendar.summary;
                            event.calendarColor = calendar.backgroundColor || '#4285f4';
                        });
                        
                        allEvents = allEvents.concat(events);
                    } catch (calendarError) {
                        console.warn(`Failed to load events from calendar ${calendar.summary}:`, calendarError);
                        
                        // If we get a 401, the token likely expired
                        if (calendarError.status === 401) {
                            console.log('Token expired during calendar loading');
                            clearGoogleAuthState();
                            updateCalendarAuthStatus();
                            return;
                        }
                    }
                }
                
                calendarEvents = allEvents;
                generateCalendar();
                
            } catch (error) {
                console.error('Error loading calendar events for widget:', error);
                
                // Handle network errors or other issues
                if (error.status === 401 || error.result?.error?.code === 401) {
                    console.log('Authentication error, clearing saved auth state');
                    clearGoogleAuthState();
                    updateCalendarAuthStatus();
                } else if (error.result?.error?.code === -1) {
                    console.log('Network error, will retry on next request');
                }
            }
        }

        // Enhanced Reddit search with working CORS proxy
        async function searchReddit(query, subreddit = '', retries = 3) {
            // Input validation
            if (!query || typeof query !== 'string') {
                console.error('Invalid query provided to searchReddit:', query);
                return null;
            }
            
            const cleanQuery = query.trim();
            if (!cleanQuery) {
                console.error('Empty query after cleaning');
                return null;
            }

            console.log(`🔍 Searching Reddit for: "${cleanQuery}"`);

            try {
                // Use pushshift.io API as it's more reliable for searches
                const pushShiftUrl = `https://api.pushshift.io/reddit/search/submission/?q=${encodeURIComponent(cleanQuery)}&size=25&sort=desc`;
                console.log('Trying Pushshift API:', pushShiftUrl);
                
                const response = await fetch(pushShiftUrl);
                
                if (response.ok) {
                    const pushShiftData = await response.json();
                    
                    if (pushShiftData.data && pushShiftData.data.length > 0) {
                        // Convert pushshift format to Reddit format
                        const redditFormatData = {
                            data: {
                                children: pushShiftData.data.map(post => ({
                                    data: {
                                        title: post.title || 'No title',
                                        url: post.url || `https://reddit.com/r/${post.subreddit}/comments/${post.id}/`,
                                        permalink: `/r/${post.subreddit}/comments/${post.id}/`,
                                        subreddit: post.subreddit || 'unknown',
                                        score: post.score || 0,
                                        num_comments: post.num_comments || 0,
                                        selftext: post.selftext || '',
                                        author: post.author || 'unknown',
                                        created_utc: post.created_utc || 0
                                    }
                                }))
                            }
                        };
                        
                        console.log(`✅ Pushshift API success: ${redditFormatData.data.children.length} posts found`);
                        return redditFormatData;
                    }
                }
                
                console.log('Pushshift API failed, trying Reddit JSON API with CORS proxy...');
                
                // Fallback to Reddit JSON API with CORS proxy
                let redditUrl;
                if (subreddit) {
                    redditUrl = `https://www.reddit.com/r/${encodeURIComponent(subreddit)}/search.json?q=${encodeURIComponent(cleanQuery)}&limit=25&sort=relevance&t=all`;
                } else {
                    redditUrl = `https://www.reddit.com/search.json?q=${encodeURIComponent(cleanQuery)}&limit=25&sort=hot&t=all`;
                }
                
                // Try with a reliable CORS proxy
                const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(redditUrl)}`;
                console.log('Trying CORS proxy:', proxyUrl);
                
                const proxyResponse = await fetch(proxyUrl);
                
                if (proxyResponse.ok) {
                    const data = await proxyResponse.json();
                    
                    if (data && data.data && Array.isArray(data.data.children)) {
                        console.log(`✅ Reddit JSON API success: ${data.data.children.length} posts found`);
                        return data;
                    }
                }
                
                console.log('CORS proxy failed, trying alternative proxy...');
                
                // Try alternative proxy
                const altProxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(redditUrl)}`;
                const altResponse = await fetch(altProxyUrl);
                
                if (altResponse.ok) {
                    const altData = await altResponse.json();
                    
                    if (altData.contents) {
                        try {
                            const parsedData = JSON.parse(altData.contents);
                            if (parsedData && parsedData.data && Array.isArray(parsedData.data.children)) {
                                console.log(`✅ Alternative proxy success: ${parsedData.data.children.length} posts found`);
                                return parsedData;
                            }
                        } catch (parseError) {
                            console.error('Failed to parse alternative proxy response:', parseError);
                        }
                    }
                }
                
            } catch (error) {
                console.error('Reddit search error:', error);
            }
            
            // Final fallback: return mock data structure
            console.log('⚠️ All Reddit strategies failed, returning fallback data');
            return {
                data: {
                    children: [{
                        data: {
                            title: `Reddit Search: "${cleanQuery}"`,
                            url: `https://www.reddit.com/search?q=${encodeURIComponent(cleanQuery)}`,
                            permalink: `/search?q=${encodeURIComponent(cleanQuery)}`,
                            subreddit: 'search',
                            score: 0,
                            num_comments: 0,
                            selftext: 'Reddit search temporarily unavailable. Click to search manually on Reddit.',
                            author: 'system',
                            created_utc: Date.now() / 1000
                        }
                    }]
                }
            };
        }

        // Enhanced general search function with GitHub and Reddit integration
        async function generalSearch() {
            const query = document.getElementById('universalSearchQuery').value.trim() || document.getElementById('socialSearchQuery').value.trim() || document.getElementById('queryInput').value.trim();
            const url = document.getElementById('urlInput').value.trim();
            
            if (!query) {
                alert('Please enter a search query');
                return;
            }

            const resultsDiv = document.getElementById('eventsResults');
            resultsDiv.innerHTML = '<div class="loading">Searching across multiple platforms...</div>';

            try {
                const allResults = [];

                // Search GitHub
                try {
                    resultsDiv.innerHTML = '<div class="loading">Searching GitHub repositories...</div>';
                    const githubData = await searchGitHub(query);
                    if (githubData && githubData.items) {
                        const githubResults = githubData.items.slice(0, 10).map(repo => ({
                            title: `${repo.name} (GitHub)`,
                            link: repo.html_url,
                            description: repo.description || 'No description available',
                            source: 'GitHub',
                            stars: repo.stargazers_count,
                            language: repo.language,
                            updated: repo.updated_at
                        }));
                        allResults.push(...githubResults);
                    }
                } catch (error) {
                    console.error('GitHub search error:', error);
                }

                // Search Reddit
                try {
                    resultsDiv.innerHTML = '<div class="loading">Searching Reddit posts...</div>';
                    const redditData = await searchReddit(query);
                    console.log('Reddit data received:', redditData);
                    
                    if (redditData && redditData.data && redditData.data.children && redditData.data.children.length > 0) {
                        const redditResults = redditData.data.children
                            .filter(post => post.data && post.data.title)
                            .slice(0, 10)
                            .map(post => {
                                const postData = post.data;
                                return {
                                    title: `${postData.title} (Reddit)`,
                                    link: postData.url.startsWith('http') ? postData.url : `https://reddit.com${postData.permalink}`,
                                    description: postData.selftext ? 
                                        (postData.selftext.length > 200 ? postData.selftext.substring(0, 200) + '...' : postData.selftext) :
                                        `Posted in r/${postData.subreddit} • Score: ${postData.score} • ${postData.num_comments} comments`,
                                    source: 'Reddit',
                                    subreddit: postData.subreddit,
                                    score: postData.score,
                                    comments: postData.num_comments
                                };
                            });
                        allResults.push(...redditResults);
                        console.log('Reddit results processed:', redditResults.length);
                    } else {
                        console.log('No Reddit results found or invalid data structure');
                    }
                } catch (error) {
                    console.error('Reddit search error:', error);
                    allResults.push({
                        title: 'Reddit Search (Limited)',
                        link: `https://www.reddit.com/search?q=${encodeURIComponent(query)}`,
                        description: 'Reddit search encountered issues. Click to search manually on Reddit.',
                        source: 'Reddit'
                    });
                }

                // Search local API if available
                try {
                    const requestBody = { query };
                    if (url) {
                        requestBody.url = url;
                    }

                    const response = await fetch('/api/search', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(requestBody)
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.events && data.events.length > 0) {
                            allResults.push(...data.events.map(event => ({
                                ...event,
                                source: 'Events'
                            })));
                        }
                        if (data.news && data.news.length > 0) {
                            allResults.push(...data.news.map(news => ({
                                ...news,
                                source: 'News'
                            })));
                        }
                    }
                } catch (error) {
                    console.error('Local search error:', error);
                }

                // Display all results
                displaySocialResults(allResults);
                
            } catch (error) {
                console.error('General search error:', error);
                resultsDiv.innerHTML = '<div style="color: var(--cyber-pink); text-align: center;">Search operation failed. Check network connection.</div>';
            }
        }

        // GitHub-only search function
        async function searchGitHubOnly() {
            const query = document.getElementById('universalSearchQuery').value.trim() || document.getElementById('socialSearchQuery').value.trim();
            if (!query) {
                alert('Please enter a search query');
                return;
            }

            const resultsDiv = document.getElementById('eventsResults');
            resultsDiv.innerHTML = '<div class="loading">Searching GitHub repositories...</div>';

            try {
                const githubData = await searchGitHub(query);
                if (githubData && githubData.items) {
                    const githubResults = githubData.items.map(repo => ({
                        title: repo.name,
                        link: repo.html_url,
                        description: repo.description || 'No description available',
                        source: 'GitHub',
                        stars: repo.stargazers_count,
                        language: repo.language,
                        updated: repo.updated_at,
                        forks: repo.forks_count,
                        issues: repo.open_issues_count
                    }));
                    displaySocialResults(githubResults);
                } else {
                    resultsDiv.innerHTML = '<div style="color: var(--cyber-pink); text-align: center;">No GitHub repositories found.</div>';
                }
            } catch (error) {
                console.error('GitHub search error:', error);
                resultsDiv.innerHTML = '<div style="color: var(--cyber-pink); text-align: center;">GitHub search failed.</div>';
            }
        }

        // Reddit-only search function
        async function searchRedditOnly() {
            const query = document.getElementById('universalSearchQuery').value.trim() || document.getElementById('socialSearchQuery').value.trim();
            if (!query) {
                alert('Please enter a search query');
                return;
            }

            const resultsDiv = document.getElementById('eventsResults');
            resultsDiv.innerHTML = '<div class="loading">Searching Reddit posts...</div>';

            try {
                const redditData = await searchReddit(query);
                if (redditData && redditData.data && redditData.data.children) {
                    const redditResults = redditData.data.children
                        .filter(post => post.data && post.data.title)
                        .map(post => {
                            const postData = post.data;
                            return {
                                title: postData.title,
                                link: postData.url.startsWith('http') ? postData.url : `https://reddit.com${postData.permalink}`,
                                description: postData.selftext || `Posted in r/${postData.subreddit}`,
                                source: 'Reddit',
                                subreddit: postData.subreddit,
                                score: postData.score,
                                comments: postData.num_comments,
                                author: postData.author
                            };
                        });
                    displaySocialResults(redditResults);
                } else {
                    resultsDiv.innerHTML = '<div style="color: var(--cyber-pink); text-align: center;">No Reddit posts found.</div>';
                }
            } catch (error) {
                console.error('Reddit search error:', error);
                resultsDiv.innerHTML = '<div style="color: var(--cyber-pink); text-align: center;">Reddit search failed.</div>';
            }
        }

        // News-only search function
        async function searchNewsOnly(query) {
            if (!query) {
                query = document.getElementById('universalSearchQuery').value.trim();
                if (!query) {
                    alert('Please enter a search query');
                    return;
                }
            }

            // Get filter options
            const category = document.getElementById('newsCategory')?.value || '';
            const timeframe = document.getElementById('newsTimeframe')?.value || '';
            const source = document.getElementById('newsSource')?.value || '';

            const resultsDiv = document.getElementById('eventsResults');
            resultsDiv.innerHTML = '<div class="loading">📰 Searching latest news...</div>';

            try {
                const requestBody = { 
                    query: query,
                    category: category,
                    timeframe: timeframe,
                    source: source
                };

                const response = await fetch('/api/search-news', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                
                if (data.articles && data.articles.length > 0) {
                    const newsResults = data.articles.map(article => ({
                        title: article.title || 'No title',
                        link: article.url || '#',
                        description: article.description || article.content || 'No description available',
                        source: article.source?.name || 'News',
                        publishedAt: article.publishedAt,
                        author: article.author,
                        urlToImage: article.urlToImage
                    }));
                    
                    displayNewsResults(newsResults);
                } else {
                    resultsDiv.innerHTML = '<div style="color: var(--cyber-pink); text-align: center;">📰 No news articles found for your query.</div>';
                }
            } catch (error) {
                console.error('News search error:', error);
                resultsDiv.innerHTML = '<div style="color: var(--cyber-pink); text-align: center;">📰 News search failed. Please try again.</div>';
            }
        }

        // Advanced analysis function
        async function performAdvancedAnalysis() {
            const query = document.getElementById('socialSearchQuery').value.trim();
            if (!query) {
                alert('Please enter a search query for analysis');
                return;
            }

            const resultsDiv = document.getElementById('eventsResults');
            resultsDiv.innerHTML = '<div class="loading">Performing advanced analysis...</div>';

            try {
                // Get data from both platforms
                const [githubData, redditData] = await Promise.all([
                    searchGitHub(query).catch(() => null),
                    searchReddit(query).catch(() => null)
                ]);

                const analysis = {
                    query,
                    github: {
                        totalRepos: githubData?.total_count || 0,
                        languages: {},
                        averageStars: 0,
                        topRepos: []
                    },
                    reddit: {
                        totalPosts: 0,
                        subreddits: {},
                        averageScore: 0,
                        topPosts: []
                    },
                    correlations: []
                };

                // Analyze GitHub data
                if (githubData && githubData.items) {
                    githubData.items.forEach(repo => {
                        if (repo.language) {
                            analysis.github.languages[repo.language] = (analysis.github.languages[repo.language] || 0) + 1;
                        }
                        analysis.github.averageStars += repo.stargazers_count;
                    });
                    analysis.github.averageStars = Math.round(analysis.github.averageStars / githubData.items.length);
                    analysis.github.topRepos = githubData.items.slice(0, 5);
                }

                // Analyze Reddit data
                if (redditData && redditData.data && redditData.data.children) {
                    analysis.reddit.totalPosts = redditData.data.children.length;
                    redditData.data.children.forEach(post => {
                        const postData = post.data;
                        if (postData.subreddit) {
                            analysis.reddit.subreddits[postData.subreddit] = (analysis.reddit.subreddits[postData.subreddit] || 0) + 1;
                        }
                        analysis.reddit.averageScore += postData.score || 0;
                    });
                    analysis.reddit.averageScore = Math.round(analysis.reddit.averageScore / analysis.reddit.totalPosts);
                    analysis.reddit.topPosts = redditData.data.children.slice(0, 5);
                }

                displayAnalysisResults(analysis);
            } catch (error) {
                console.error('Analysis error:', error);
                resultsDiv.innerHTML = '<div style="color: var(--cyber-pink); text-align: center;">Advanced analysis failed.</div>';
            }
        }

        // Display social search results
        function displaySocialResults(results) {
            const resultsDiv = document.getElementById('eventsResults');
            
            if (!results || results.length === 0) {
                resultsDiv.innerHTML = '<div style="text-align: center; color: #666;">No results found across platforms.</div>';
                return;
            }

            const getSourceColor = (source) => {
                switch(source) {
                    case 'GitHub': return 'var(--cyber-green)';
                    case 'Reddit': return 'var(--cyber-orange)';
                    case 'Events': return 'var(--cyber-blue)';
                    case 'News': return 'var(--cyber-pink)';
                    default: return 'var(--cyber-purple)';
                }
            };

            const socialResultsHTML = `
                <div style="text-align: center; margin-bottom: 20px; padding: 15px; background: rgba(0, 255, 255, 0.1); border-radius: 10px;">
                    <p style="color: var(--cyber-blue); font-weight: bold;">
                        🌐 Found ${results.length} results across social platforms
                    </p>
                </div>
                ${results.map((result, index) => {
                    const title = result.title || `Result ${index + 1}`;
                    const link = result.link || '#';
                    const description = result.description || 'No description available';
                    const source = result.source || 'Unknown';
                    
                    let extraInfo = '';
                    if (source === 'GitHub') {
                        extraInfo = `
                            <div style="margin-top: 8px; font-size: 0.8rem;">
                                ${result.stars ? `⭐ ${result.stars} stars` : ''} 
                                ${result.language ? `• 💻 ${result.language}` : ''} 
                                ${result.forks ? `• 🍴 ${result.forks} forks` : ''}
                            </div>
                        `;
                    } else if (source === 'Reddit') {
                        extraInfo = `
                            <div style="margin-top: 8px; font-size: 0.8rem;">
                                📊 ${result.score || 0} points • 💬 ${result.comments || 0} comments • 📍 r/${result.subreddit || 'unknown'}
                            </div>
                        `;
                    }
                    
                    // Unique id for the result so we can star it
                    const resultId = result.id || result.link || `${source}-${index}`;
                    const isStarred = isItemStarred(resultId);
                    return `
                        <div class="history-item" style="margin-bottom: 15px; padding: 15px; background: rgba(0, 0, 0, 0.3); position: relative;">
                            <div style="position: absolute; top: 12px; right: 12px;">
                                <button class="star-btn ${isStarred ? 'starred' : ''}" onclick="toggleStar('${escapeForJS(resultId)}', '${encodeURIComponent(JSON.stringify({title: title, description: description, link: link}))}')" title="⭐ Star and add to Google Calendar" style="padding:6px 8px; border-radius:6px; background: rgba(0,255,255,0.2) !important; border:1px solid var(--cyber-blue) !important; color: var(--cyber-blue) !important; font-weight: bold !important;">
                                    ${isStarred ? '★ Starred' : '☆ Star'}
                                </button>
                            </div>
                            <div class="history-content">
                                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                                    <div style="flex: 1;">
                                        <div class="history-query" style="color: var(--cyber-blue); font-size: 1rem; margin-bottom: 5px;">${title}</div>
                                        <span style="color: ${getSourceColor(source)}; font-size: 0.8rem; font-weight: bold; text-transform: uppercase; background: rgba(0,0,0,0.5); padding: 2px 6px; border-radius: 10px;">
                                            ${source}
                                        </span>
                                    </div>
                                </div>
                                <a href="${link}" target="_blank" style="color: var(--cyber-green); text-decoration: none; font-size: 0.9rem; display: block; margin: 8px 0;">${link}</a>
                                <div style="color: #ccc; font-size: 0.9rem; line-height: 1.4;">${description}</div>
                                ${extraInfo}
                            </div>
                        </div>
                    `;
                }).join('')}
            `;

            resultsDiv.innerHTML = socialResultsHTML;
        }

        // Star management: persist starred items, toggle UI, and optionally add to Google Calendar
        const starredItemsKey = 'prospectorStarredItems';

        function getStarredItems() {
            try {
                return JSON.parse(localStorage.getItem(starredItemsKey) || '{}');
            } catch (e) { return {}; }
        }

        function isItemStarred(id) {
            const items = getStarredItems();
            return !!items[id];
        }

        function saveStarredItems(items) {
            localStorage.setItem(starredItemsKey, JSON.stringify(items || {}));
        }

        // escape simple string for inline JS call
        function escapeForJS(s) {
            return String(s || '').replace(/\\/g,'\\\\').replace(/'/g,"\\'").replace(/\"/g,'\\\"');
        }

        async function toggleStar(id, meta) {
            // Decode the metadata if it's a string (from encodeURIComponent)
            if (typeof meta === 'string') {
                try {
                    meta = JSON.parse(decodeURIComponent(meta));
                } catch (error) {
                    console.error('Failed to decode metadata:', error);
                    meta = { title: 'Starred item' }; // fallback
                }
            }
            
            const items = getStarredItems();
            const isStarredNow = !!items[id];

            // If user authenticated, prefer server sync
            if (currentUser) {
                try {
                    if (isStarredNow) {
                        // find wish id in server: best-effort by matching eventUrl or title
                        // We'll attempt to delete by searching user's wishes first
                        const listResp = await fetch('/api/user/wishes', { credentials: 'include' });
                        if (listResp.ok) {
                            const data = await listResp.json();
                            const found = (data.wishes || []).find(w => (w.eventUrl === (meta.link || '') ) || (w.eventTitle === (meta.title || '')) );
                            if (found) {
                                await fetch(`/api/user/wishes/${found._id}`, { method: 'DELETE', credentials: 'include' });
                            }
                        }

                        delete items[id];
                        saveStarredItems(items);
                        document.querySelectorAll(`button.star-btn`).forEach(btn => {
                            if (btn.getAttribute('onclick') && btn.getAttribute('onclick').includes(id)) {
                                btn.classList.remove('starred'); btn.textContent = '☆ Star';
                            }
                        });
                        showNotification('⭐ Removed from favorites', 'info');
                        return;
                    }

                    // Create wish on server
                    const wishBody = {
                        eventTitle: (meta && meta.title) || 'Starred item',
                        eventDescription: (meta && meta.description) || '',
                        eventUrl: (meta && meta.link) || '',
                        eventDate: (meta && meta.eventDate) || undefined,
                        eventTime: (meta && meta.eventTime) || undefined,
                        eventLocation: (meta && meta.eventLocation) || undefined,
                        source: (meta && meta.source) || 'prospector'
                    };

                    const createResp = await fetch('/api/user/wishes', {
                        method: 'POST',
                        credentials: 'include',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(wishBody)
                    });

                    if (!createResp.ok) throw new Error('Failed to save favorite to server');
                    const created = await createResp.json();

                    // Persist locally as well for quick UI
                    items[id] = { meta: meta || {}, starredAt: new Date().toISOString(), serverId: created.wish._id };
                    saveStarredItems(items);

                    document.querySelectorAll(`button.star-btn`).forEach(btn => {
                        if (btn.getAttribute('onclick') && btn.getAttribute('onclick').includes(id)) {
                            btn.classList.add('starred'); btn.textContent = '★ Starred';
                        }
                    });

                    showNotification('⭐ Saved to favorites', 'success');

                    // Add to Google Calendar if signed in
                    if (isGoogleSignedIn && typeof gapi !== 'undefined' && gapi.client && gapi.client.calendar) {
                        try {
                            await addToGoogleCalendar(meta);
                            showNotification('📅 Also added to Google Calendar', 'success');
                        } catch (err) {
                            console.warn('Failed to add to Google Calendar:', err);
                            showNotification('⭐ Starred, but failed to add to Google Calendar', 'warning');
                        }
                    } else {
                        showNotification('⭐ Starred! Sign in to Google Calendar to auto-add events', 'info');
                    }
                    return;
                } catch (err) {
                    console.error('Server sync for favorites failed, falling back to local:', err);
                    showNotification('⚠️ Could not sync favorite to server; saved locally', 'error');
                    // continue to fallback local behavior
                }
            }

            // Local-only flow (guest or server failure)
            if (isStarredNow) {
                delete items[id];
                saveStarredItems(items);
                document.querySelectorAll(`button.star-btn`).forEach(btn => {
                    if (btn.getAttribute('onclick') && btn.getAttribute('onclick').includes(id)) {
                        btn.classList.remove('starred'); btn.textContent = '☆ Star';
                    }
                });
                showNotification('⭐ Removed from starred items', 'info');
                return;
            }

            items[id] = { meta: meta || {}, starredAt: new Date().toISOString() };
            saveStarredItems(items);
            document.querySelectorAll(`button.star-btn`).forEach(btn => {
                if (btn.getAttribute('onclick') && btn.getAttribute('onclick').includes(id)) {
                    btn.classList.add('starred'); btn.textContent = '★ Starred';
                }
            });
            showNotification('⭐ Added to starred items (local)', 'success');
        }

        // Add starred item to Google Calendar with smart event timing
        async function addToGoogleCalendar(meta) {
            if (!isGoogleSignedIn || !gapi.client.calendar) {
                throw new Error('Google Calendar not available');
            }

            // Ensure meta is an object
            if (!meta || typeof meta !== 'object') {
                meta = { title: 'Starred Item' };
            }

            const title = meta.title || 'Starred Item';
            const description = meta.description || '';
            const link = meta.link || '';
            
            // Smart event timing based on the type of item
            let startTime, endTime;
            
            if (meta.eventDate || meta.eventTime) {
                // If the item has specific date/time info, use it
                if (meta.eventDate && meta.eventTime) {
                    startTime = new Date(`${meta.eventDate} ${meta.eventTime}`);
                } else if (meta.eventDate) {
                    // If only date, make it an all-day event
                    startTime = new Date(meta.eventDate);
                    startTime.setHours(9, 0, 0, 0); // 9 AM default
                } else {
                    // If only time today, use today's date
                    startTime = new Date();
                    const timeParts = meta.eventTime.split(':');
                    startTime.setHours(parseInt(timeParts[0]), parseInt(timeParts[1] || 0), 0, 0);
                }
                endTime = new Date(startTime.getTime() + 60 * 60 * 1000); // 1 hour duration
            } else {
                // For items without specific timing, schedule for later today or tomorrow
                startTime = new Date();
                if (startTime.getHours() >= 18) {
                    // If it's after 6 PM, schedule for tomorrow 9 AM
                    startTime.setDate(startTime.getDate() + 1);
                    startTime.setHours(9, 0, 0, 0);
                } else {
                    // Otherwise, schedule for 2 hours from now
                    startTime = new Date(Date.now() + 2 * 60 * 60 * 1000);
                }
                endTime = new Date(startTime.getTime() + 60 * 60 * 1000); // 1 hour duration
            }

            // Create comprehensive event description
            let eventDescription = description;
            if (link) {
                eventDescription += `\n\n🔗 Link: ${link}`;
            }
            if (meta.eventLocation) {
                eventDescription += `\n📍 Location: ${meta.eventLocation}`;
            }
            if (meta.source) {
                eventDescription += `\n\n📱 Added from: ${meta.source}`;
            }
            eventDescription += `\n\n⭐ Starred via The Prospector`;

            const event = {
                summary: `⭐ ${title}`,
                description: eventDescription,
                start: {
                    dateTime: startTime.toISOString(),
                    timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                },
                end: {
                    dateTime: endTime.toISOString(),
                    timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                },
                reminders: {
                    useDefault: false,
                    overrides: [
                        { method: 'popup', minutes: 15 }
                    ]
                }
            };

            // Add location if available
            if (meta.eventLocation) {
                event.location = meta.eventLocation;
            }

            await gapi.client.calendar.events.insert({
                calendarId: 'primary',
                resource: event
            });

            console.log('Event added to Google Calendar:', title);
        }

        // Sync local favorites to server when user logs in
        async function syncLocalFavoritesToServer() {
            if (!currentUser) return;
            const items = getStarredItems();
            const keys = Object.keys(items || {});
            if (keys.length === 0) return;

            try {
                // Fetch existing server-side wishes to avoid duplicates
                const listResp = await fetch('/api/user/wishes', { credentials: 'include' });
                let serverWishes = [];
                if (listResp.ok) {
                    const data = await listResp.json();
                    serverWishes = data.wishes || [];
                }

                for (const key of keys) {
                    const local = items[key];
                    // If already has serverId, skip
                    if (local.serverId) continue;

                    // Check dedupe by URL or title
                    const meta = local.meta || {};
                    const already = serverWishes.find(w => (w.eventUrl && meta.link && w.eventUrl === meta.link) || (w.eventTitle && meta.title && w.eventTitle === meta.title));
                    if (already) {
                        // store server id locally for future deletes
                        items[key].serverId = already._id;
                        saveStarredItems(items);
                        continue;
                    }

                    // Create on server
                    const wishBody = {
                        eventTitle: meta.title || 'Starred item',
                        eventDescription: meta.description || '',
                        eventUrl: meta.link || '',
                        eventDate: meta.eventDate || undefined,
                        eventTime: meta.eventTime || undefined,
                        eventLocation: meta.eventLocation || undefined,
                        source: meta.source || 'prospector'
                    };

                    try {
                        const createResp = await fetch('/api/user/wishes', {
                            method: 'POST',
                            credentials: 'include',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(wishBody)
                        });

                        if (!createResp.ok) {
                            console.warn('Failed to create wish for', key, await createResp.text());
                            continue;
                        }

                        const created = await createResp.json();
                        items[key].serverId = created.wish._id;
                        saveStarredItems(items);

                        // Optionally add to Google Calendar if signed in
                        if (isGoogleSignedIn && typeof gapi !== 'undefined' && gapi.client && gapi.client.calendar) {
                            try {
                                const title = meta.title || 'Starred item';
                                const description = meta.description || '';
                                const link = meta.link || '';
                                const start = new Date(Date.now() + 60 * 60 * 1000);
                                const end = new Date(start.getTime() + 60 * 60 * 1000);
                                const event = {
                                    summary: title,
                                    description: description + (link ? `\n\nLink: ${link}` : ''),
                                    start: { dateTime: start.toISOString(), timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone },
                                    end: { dateTime: end.toISOString(), timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone }
                                };
                                await gapi.client.calendar.events.insert({ calendarId: 'primary', resource: event });
                            } catch (err) {
                                console.warn('Calendar insert during sync failed:', err);
                            }
                        }

                    } catch (err) {
                        console.error('Error creating wish during sync for', key, err);
                    }
                }

            } catch (err) {
                console.error('Favorites sync failed:', err);
                throw err;
            }
        }

        // Display news search results
        function displayNewsResults(results) {
            const resultsDiv = document.getElementById('eventsResults');
            
            if (!results || results.length === 0) {
                resultsDiv.innerHTML = '<div style="text-align: center; color: #666;">📰 No news articles found.</div>';
                return;
            }

            const formatDate = (dateString) => {
                if (!dateString) return '';
                const date = new Date(dateString);
                return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            };

            const newsResultsHTML = `
                <div style="text-align: center; margin-bottom: 20px; padding: 15px; background: rgba(255, 0, 128, 0.1); border-radius: 10px;">
                    <p style="color: var(--cyber-pink); font-weight: bold;">
                        📰 Found ${results.length} news articles
                    </p>
                </div>
                ${results.map((article, index) => {
                    const title = article.title || `Article ${index + 1}`;
                    const link = article.link || '#';
                    const description = article.description || 'No description available';
                    const source = article.source || 'News';
                    const publishedAt = article.publishedAt ? formatDate(article.publishedAt) : '';
                    const author = article.author || '';
                    
                    return `
                        <div class="history-item" style="margin-bottom: 15px; padding: 15px; background: rgba(0, 0, 0, 0.3); border-left: 4px solid var(--cyber-pink);">
                            <div class="history-content">
                                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                                    <div style="flex: 1;">
                                        <div class="history-query" style="color: var(--cyber-blue); font-size: 1rem; margin-bottom: 5px;">${title}</div>
                                        <div style="display: flex; gap: 10px; align-items: center;">
                                            <span style="color: var(--cyber-pink); font-size: 0.8rem; font-weight: bold; text-transform: uppercase; background: rgba(255,0,128,0.2); padding: 2px 6px; border-radius: 10px;">
                                                📰 ${source}
                                            </span>
                                            ${publishedAt ? `<span style="color: var(--cyber-green); font-size: 0.8rem;">🕒 ${publishedAt}</span>` : ''}
                                            ${author ? `<span style="color: var(--cyber-orange); font-size: 0.8rem;">✍️ ${author}</span>` : ''}
                                        </div>
                                    </div>
                                </div>
                                <a href="${link}" target="_blank" style="color: var(--cyber-green); text-decoration: none; font-size: 0.9rem; display: block; margin: 8px 0;">${link}</a>
                                <div style="color: #ccc; font-size: 0.9rem; line-height: 1.4;">${description}</div>
                                ${article.urlToImage ? `<div style="margin-top: 10px;"><img src="${article.urlToImage}" alt="Article Image" style="max-width: 100%; height: auto; border-radius: 5px; max-height: 200px;" onerror="this.style.display='none'"></div>` : ''}
                            </div>
                        </div>
                    `;
                }).join('')}
            `;

            resultsDiv.innerHTML = newsResultsHTML;
        }

        // Display analysis results
        function displayAnalysisResults(analysis) {
            const resultsDiv = document.getElementById('eventsResults');
            
            const analysisHTML = `
                <div style="text-align: center; margin-bottom: 20px; padding: 15px; background: rgba(139, 0, 255, 0.2); border-radius: 10px; border: 2px solid var(--cyber-purple);">
                    <h3 style="color: var(--cyber-purple); margin-bottom: 10px;">🔬 Advanced Analysis: "${analysis.query}"</h3>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                    <div style="background: rgba(0, 255, 65, 0.1); border: 2px solid var(--cyber-green); border-radius: 10px; padding: 15px;">
                        <h4 style="color: var(--cyber-green); margin-bottom: 10px;">📊 GitHub Analysis</h4>
                        <p>Total Repositories: <strong>${analysis.github.totalRepos}</strong></p>
                        <p>Average Stars: <strong>${analysis.github.averageStars}</strong></p>
                        <p>Top Languages: <strong>${Object.keys(analysis.github.languages).slice(0, 3).join(', ')}</strong></p>
                    </div>
                    
                    <div style="background: rgba(255, 107, 0, 0.1); border: 2px solid var(--cyber-orange); border-radius: 10px; padding: 15px;">
                        <h4 style="color: var(--cyber-orange); margin-bottom: 10px;">📊 Reddit Analysis</h4>
                        <p>Total Posts: <strong>${analysis.reddit.totalPosts}</strong></p>
                        <p>Average Score: <strong>${analysis.reddit.averageScore}</strong></p>
                        <p>Top Subreddits: <strong>${Object.keys(analysis.reddit.subreddits).slice(0, 3).join(', ')}</strong></p>
                    </div>
                </div>
                
                <div style="background: rgba(0, 255, 255, 0.1); border: 2px solid var(--cyber-blue); border-radius: 10px; padding: 15px;">
                    <h4 style="color: var(--cyber-blue); margin-bottom: 15px;">🔍 Detailed Insights</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div>
                            <h5 style="color: var(--cyber-green); margin-bottom: 10px;">Top GitHub Repos:</h5>
                            ${analysis.github.topRepos.map(repo => `
                                <div style="margin-bottom: 8px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 5px;">
                                    <a href="${repo.html_url}" target="_blank" style="color: var(--cyber-blue); text-decoration: none;">${repo.name}</a>
                                    <div style="font-size: 0.8rem; color: #888;">⭐ ${repo.stargazers_count} stars</div>
                                </div>
                            `).join('')}
                        </div>
                        
                        <div>
                            <h5 style="color: var(--cyber-orange); margin-bottom: 10px;">Top Reddit Posts:</h5>
                            ${analysis.reddit.topPosts.map(post => `
                                <div style="margin-bottom: 8px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 5px;">
                                    <a href="https://reddit.com${post.data.permalink}" target="_blank" style="color: var(--cyber-blue); text-decoration: none; font-size: 0.9rem;">${post.data.title.substring(0, 50)}...</a>
                                    <div style="font-size: 0.8rem; color: #888;">📊 ${post.data.score} points • r/${post.data.subreddit}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;

            resultsDiv.innerHTML = analysisHTML;
        }

        // Intelligent Search System
        let currentSearchMode = 'auto';

        function setSearchMode(mode) {
            currentSearchMode = mode;

            // Update button states (guard in case buttons are missing)
            const modeButtons = document.querySelectorAll('.mode-button');
            if (modeButtons && modeButtons.length) {
                modeButtons.forEach(btn => btn.classList.remove('active'));
            }
            const targetBtn = document.getElementById(mode + 'Mode');
            if (targetBtn && targetBtn.classList) {
                targetBtn.classList.add('active');
            }

            // Update mode indicator (guard)
            const indicators = {
                'auto': '🤖 Auto Mode: AI will analyze your query and choose the best search strategy',
                'events': '📅 Events Mode: Focus on local events and activities',
                'github': '💻 Code Mode: Search GitHub repositories and code-related content',
                'reddit': '💬 Community Mode: Search Reddit posts and discussions',
                'news': '📰 News Mode: Search for latest news and articles',
                'social': '🌐 Social Mode: Search across all social platforms simultaneously',
                'calendar': '📅 Calendar Mode: View and manage your Google Calendar events'
            };

            const modeIndicatorEl = document.getElementById('modeIndicator');
            if (modeIndicatorEl) {
                modeIndicatorEl.innerHTML = indicators[mode] || '';
            }

            // Show/hide calendar section based on mode (guard missing sections)
            const calendarSection = document.getElementById('calendarSection');
            const resultsSection = document.getElementById('resultsSection') || document.getElementById('mainResultsSection');

            if (mode === 'calendar') {
                if (calendarSection) calendarSection.style.display = 'block';
                if (resultsSection) resultsSection.style.display = 'none';
                // Initialize calendar if needed
                if (typeof initializeGoogleApis === 'function') {
                    initializeGoogleApis();
                }
            } else {
                if (calendarSection) calendarSection.style.display = 'none';
                if (resultsSection) resultsSection.style.display = 'block';
            }

            // Update search button text
            const buttonTexts = {
                'auto': '🚀 Smart Search',
                'events': '📅 Find Events',
                'github': '💻 Search Code',
                'reddit': '💬 Search Community',
                'news': '📰 Find News',
                'social': '🌐 Search All',
                'calendar': '📅 View Calendar'
            };
            
            document.getElementById('searchButton').innerHTML = buttonTexts[mode];
        }

        // AI Query Analysis
        function analyzeQuery(query) {
            const lowercaseQuery = query.toLowerCase();
            
            // Coding/GitHub indicators
            const codingKeywords = [
                'code', 'programming', 'github', 'repository', 'repo', 'javascript', 'python', 'java', 'react', 'node',
                'api', 'library', 'framework', 'algorithm', 'function', 'class', 'method', 'variable', 'syntax',
                'debug', 'error', 'bug', 'compile', 'build', 'deploy', 'git', 'version control', 'open source',
                'npm', 'pip', 'maven', 'gradle', 'docker', 'kubernetes', 'aws', 'cloud', 'database', 'sql',
                'html', 'css', 'typescript', 'angular', 'vue', 'svelte', 'backend', 'frontend', 'fullstack',
                'machine learning', 'ai', 'data science', 'analytics', 'visualization', 'pandas', 'tensorflow'
            ];
            
            // Reddit/Community indicators
            const communityKeywords = [
                'discussion', 'opinion', 'thoughts', 'advice', 'help', 'community', 'reddit', 'forum',
                'question', 'ask', 'share', 'experience', 'story', 'ama', 'til', 'eli5', 'dae',
                'unpopular opinion', 'shower thoughts', 'life pro tip', 'what if', 'how do you',
                'anyone else', 'people', 'users', 'redditors', 'subreddit', 'thread', 'post',
                'upvote', 'downvote', 'karma', 'comment', 'reply', 'meta', 'circlejerk'
            ];
            
            // Events indicators
            const eventKeywords = [
                'event', 'meetup', 'conference', 'workshop', 'seminar', 'festival', 'concert', 'show',
                'happening', 'tonight', 'today', 'weekend', 'location', 'venue', 'tickets', 'rsvp',
                'networking', 'gathering', 'party', 'celebration', 'fair', 'expo', 'convention',
                'live', 'performance', 'exhibition', 'demo', 'presentation', 'talk', 'lecture',
                'near me', 'local', 'nearby', 'this week', 'upcoming', 'schedule', 'calendar'
            ];

            // News indicators
            const newsKeywords = [
                'news', 'breaking', 'latest', 'update', 'report', 'article', 'headline', 'story',
                'current events', 'politics', 'election', 'government', 'world news', 'local news',
                'coronavirus', 'covid', 'economy', 'business', 'technology news', 'sports news',
                'weather', 'climate', 'breaking news', 'developing', 'announcement', 'press release',
                'investigation', 'scandal', 'crisis', 'protest', 'war', 'conflict', 'diplomacy',
                'market', 'stocks', 'finance', 'earnings', 'gdp', 'inflation', 'recession',
                'celebrity', 'entertainment', 'movie', 'tv show', 'music news', 'awards',
                'what happened', 'today\'s news', 'yesterday', 'trending', 'viral'
            ];

            let codeScore = 0;
            let communityScore = 0;
            let eventScore = 0;
            let newsScore = 0;

            // Calculate scores
            codingKeywords.forEach(keyword => {
                if (lowercaseQuery.includes(keyword)) {
                    codeScore += keyword.length > 3 ? 2 : 1;
                }
            });

            communityKeywords.forEach(keyword => {
                if (lowercaseQuery.includes(keyword)) {
                    communityScore += keyword.length > 3 ? 2 : 1;
                }
            });

            eventKeywords.forEach(keyword => {
                if (lowercaseQuery.includes(keyword)) {
                    eventScore += keyword.length > 3 ? 2 : 1;
                }
            });

            newsKeywords.forEach(keyword => {
                if (lowercaseQuery.includes(keyword)) {
                    newsScore += keyword.length > 3 ? 2 : 1;
                }
            });

            // Determine best mode
            const maxScore = Math.max(codeScore, communityScore, eventScore, newsScore);
            
            if (maxScore === 0) {
                return { mode: 'social', confidence: 0.5, reason: 'No specific indicators found, using social mode' };
            }
            
            if (codeScore === maxScore) {
                return { mode: 'github', confidence: codeScore / 10, reason: 'Detected coding/programming content' };
            } else if (communityScore === maxScore) {
                return { mode: 'reddit', confidence: communityScore / 10, reason: 'Detected community discussion content' };
            } else if (newsScore === maxScore) {
                return { mode: 'news', confidence: newsScore / 10, reason: 'Detected news/current events content' };
            } else {
                return { mode: 'events', confidence: eventScore / 10, reason: 'Detected event-related content' };
            }
        }

        // Intelligent Search Function
        async function performIntelligentSearch() {
            const query = document.getElementById('universalSearchQuery').value.trim();
            const location = document.getElementById('universalLocationInput').value.trim();
            
            if (!query) {
                alert('Please enter a search query');
                return;
            }

            const modeIndicator = document.getElementById('modeIndicator');
            const resultsDiv = document.getElementById('eventsResults');
            
            let searchMode = currentSearchMode;
            let analysis = null;

            // Auto mode: analyze query
            if (currentSearchMode === 'auto') {
                modeIndicator.classList.add('detecting');
                modeIndicator.innerHTML = '🤖 Analyzing query...';
                
                analysis = analyzeQuery(query);
                searchMode = analysis.mode;
                
                setTimeout(() => {
                    modeIndicator.classList.remove('detecting');
                    modeIndicator.innerHTML = `🎯 Auto-detected: ${analysis.mode.toUpperCase()} mode (${(analysis.confidence * 100).toFixed(0)}% confidence) - ${analysis.reason}`;
                }, 1000);
                
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            // Save search to history
            const eventsCount = 0; // Will be updated after search
            const newsCount = 0;
            saveSearch(query, eventsCount, newsCount);

            // Execute search based on determined mode
            try {
                switch (searchMode) {
                    case 'github':
                        resultsDiv.innerHTML = '<div class="loading">🔍 Searching GitHub repositories...</div>';
                        await searchGitHubOnly();
                        break;
                    
                    case 'reddit':
                        resultsDiv.innerHTML = '<div class="loading">🔍 Searching Reddit discussions...</div>';
                        await searchRedditOnly();
                        break;
                    
                    case 'events':
                        if (!location) {
                            document.getElementById('universalLocationInput').focus();
                            alert('Please enter a location for event search');
                            return;
                        }
                        resultsDiv.innerHTML = '<div class="loading">🔍 Searching for events...</div>';
                        // Copy location to the detailed event search input and trigger search
                        document.getElementById('locationInput').value = location;
                        await searchEvents();
                        break;
                    
                    case 'news':
                        resultsDiv.innerHTML = '<div class="loading">📰 Searching latest news...</div>';
                        await searchNewsOnly(query);
                        break;
                    
                    case 'social':
                        resultsDiv.innerHTML = '<div class="loading">🔍 Searching all platforms...</div>';
                        await generalSearch();
                        break;
                    
                    default:
                        resultsDiv.innerHTML = '<div class="loading">🔍 Performing comprehensive search...</div>';
                        await generalSearch();
                }
                
                // Show analysis results if auto mode was used
                if (currentSearchMode === 'auto' && analysis) {
                    const analysisDiv = document.createElement('div');
                    analysisDiv.innerHTML = `
                        <div style="background: rgba(0, 255, 255, 0.1); border: 2px solid var(--cyber-blue); border-radius: 10px; padding: 15px; margin-bottom: 20px;">
                            <h4 style="color: var(--cyber-blue); margin-bottom: 10px;">🤖 AI Analysis Results</h4>
                            <p><strong>Detected Mode:</strong> ${searchMode.toUpperCase()}</p>
                            <p><strong>Confidence:</strong> ${(analysis.confidence * 100).toFixed(0)}%</p>
                            <p><strong>Reasoning:</strong> ${analysis.reason}</p>
                        </div>
                    `;
                    resultsDiv.insertBefore(analysisDiv, resultsDiv.firstChild);
                }
                
            } catch (error) {
                console.error('Intelligent search error:', error);
                resultsDiv.innerHTML = '<div style="color: var(--cyber-pink); text-align: center;">Search failed. Please try again.</div>';
            }
        }
        // Create floating particles
        function createParticles() {
            const particleContainer = document.getElementById('particles');
            const colors = ['#00ffff', '#ff0080', '#00ff41', '#ff6b00', '#8b00ff'];
            
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 6 + 's';
                particle.style.animationDuration = (Math.random() * 3 + 3) + 's';
                particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                particleContainer.appendChild(particle);
            }
        }

        // Global variables for current data and tab management
        let currentEventsData = null;
        let currentActiveTab = 'events';

        // Tab switching functionality
        function switchTab(tabName) {
            currentActiveTab = tabName;
            
            // Update tab buttons
            document.getElementById('eventsTab').style.background = tabName === 'events' ? 'var(--cyber-blue)' : 'rgba(0, 255, 255, 0.2)';
            document.getElementById('eventsTab').style.color = tabName === 'events' ? 'black' : 'var(--cyber-blue)';
            document.getElementById('newsTab').style.background = tabName === 'news' ? 'var(--cyber-blue)' : 'rgba(0, 255, 255, 0.2)';
            document.getElementById('newsTab').style.color = tabName === 'news' ? 'black' : 'var(--cyber-blue)';
            
            // Show/hide content
            document.getElementById('eventsContent').style.display = tabName === 'events' ? 'block' : 'none';
            document.getElementById('newsContent').style.display = tabName === 'news' ? 'block' : 'none';
            
            // If we have current data, re-display it for the active tab
            if (currentEventsData) {
                displaySeparatedResults(currentEventsData);
            }
        }

        // Enhanced sorting function
        function sortEvents(events, sortBy) {
            return [...events].sort((a, b) => {
                switch(sortBy) {
                    case 'date':
                        return new Date(a.date || 0) - new Date(b.date || 0);
                    case 'popularity':
                        return (b.attendees || 0) - (a.attendees || 0);
                    case 'source':
                        const sourceQuality = {'Ticketmaster': 5, 'Eventbrite': 4, 'NewsAPI': 3, 'OpenWeather': 2, 'API-Ninja': 1};
                        return (sourceQuality[b.source] || 0) - (sourceQuality[a.source] || 0);
                    case 'price':
                        const aFree = a.isFree || a.price === 'Free' || !a.price;
                        const bFree = b.isFree || b.price === 'Free' || !b.price;
                        if (aFree && !bFree) return -1;
                        if (!aFree && bFree) return 1;
                        return 0;
                    case 'relevance':
                    default:
                        return (b.relevanceScore || b.confidence || 0) - (a.relevanceScore || a.confidence || 0);
                }
            });
        }

        // Filter events based on focus
        function filterEvents(events, focus) {
            return events.filter(event => {
                switch(focus) {
                    case 'today':
                        const today = new Date().toDateString();
                        return event.date && new Date(event.date).toDateString() === today;
                    case 'free':
                        return event.isFree || event.price === 'Free' || !event.price;
                    case 'ticketed':
                        return !event.isFree && event.price && event.price !== 'Free';
                    case 'nearby':
                        return event.coordinates || event.location;
                    case 'all':
                    default:
                        return true;
                }
            });
        }

        // Comprehensive Search Function - Uses All APIs
        async function performComprehensiveSearch() {
            const query = document.getElementById('universalSearchQuery').value.trim();
            const location = document.getElementById('universalLocationInput').value.trim();
            
            if (!query) {
                alert('Please enter a search query');
                return;
            }

            const resultsDiv = document.getElementById('eventsResults');
            resultsDiv.innerHTML = '<div class="loading">🚀 Searching across all platforms and APIs...</div>';

            try {
                // Determine search mode based on current selection or auto-detect
                let searchMode = currentSearchMode;
                if (currentSearchMode === 'auto') {
                    const analysis = analyzeQuery(query);
                    searchMode = analysis.mode;
                    
                    // Show analysis results
                    setTimeout(() => {
                        resultsDiv.innerHTML = `
                            <div class="loading">
                                🤖 AI detected: ${analysis.mode.toUpperCase()} mode (${Math.round(analysis.confidence * 100)}% confidence)<br>
                                ${analysis.reason}<br><br>
                                🔍 Searching across all APIs...
                            </div>
                        `;
                    }, 500);
                }

                // Create search promises for all relevant APIs
                const searchPromises = [];

                // Always search events if location is provided or if it's event mode
                if (location || searchMode === 'events') {
                    searchPromises.push(
                        fetch(`/api/search-events?location=${encodeURIComponent(location || query)}&genre=${encodeURIComponent(query)}`)
                            .then(res => res.json())
                            .then(data => ({ type: 'events', data }))
                            .catch(err => ({ type: 'events', error: err.message }))
                    );
                }

                // Always search news
                searchPromises.push(
                    fetch('/api/search-news', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ query })
                    })
                        .then(res => res.json())
                        .then(data => ({ type: 'news', data }))
                        .catch(err => ({ type: 'news', error: err.message }))
                );

                // Search GitHub if relevant
                if (searchMode === 'github' || searchMode === 'auto' || searchMode === 'social') {
                    searchPromises.push(
                        searchGitHub(query)
                            .then(data => ({ type: 'github', data }))
                            .catch(err => ({ type: 'github', error: err.message }))
                    );
                }

                // Search Reddit if relevant
                if (searchMode === 'reddit' || searchMode === 'auto' || searchMode === 'social') {
                    searchPromises.push(
                        searchReddit(query)
                            .then(data => ({ type: 'reddit', data }))
                            .catch(err => ({ type: 'reddit', error: err.message }))
                    );
                }

                // Execute all searches in parallel
                const results = await Promise.allSettled(searchPromises);
                
                // Process and combine results
                displayComprehensiveResults(results, query, location, searchMode);

            } catch (error) {
                console.error('Comprehensive search error:', error);
                resultsDiv.innerHTML = '<div style="color: var(--cyber-pink); text-align: center;">Search failed. Please try again.</div>';
            }
        }

        // Display comprehensive results from all APIs
        function displayComprehensiveResults(results, query, location, searchMode) {
            const resultsDiv = document.getElementById('eventsResults');
            let allResults = [];
            let eventCount = 0;
            let newsCount = 0;
            let githubCount = 0;
            let redditCount = 0;

            // Process each result type
            results.forEach(result => {
                if (result.status === 'fulfilled' && result.value && !result.value.error) {
                    const { type, data } = result.value;
                    
                    switch(type) {
                        case 'events':
                            if (data.events && data.events.length > 0) {
                                eventCount = data.events.length;
                                data.events.forEach(event => {
                                    // Parse event timing more thoroughly
                                    let eventDate = event.date || event.start_date || event.start_time || event.datetime_local;
                                    let eventTime = null;
                                    let endTime = null;
                                    
                                    // Try to extract start and end times
                                    if (event.datetime_local) {
                                        const startDate = new Date(event.datetime_local);
                                        eventDate = startDate.toISOString().split('T')[0];
                                        eventTime = startDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                                    }
                                    
                                    if (event.end_time || event.datetime_local_end) {
                                        const endDate = new Date(event.end_time || event.datetime_local_end);
                                        endTime = endDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                                    }
                                    
                                    allResults.push({
                                        type: 'event',
                                        title: event.title || event.name,
                                        description: event.description || event.summary,
                                        link: event.url || event.link,
                                        venue: event.venue || event.location,
                                        date: eventDate,
                                        time: eventTime,
                                        endTime: endTime,
                                        source: 'Events API',
                                        metadata: {
                                            eventDate: eventDate,
                                            eventTime: eventTime,
                                            eventLocation: event.venue || event.location,
                                            source: 'Events API'
                                        }
                                    });
                                });
                            }
                            break;

                        case 'news':
                            if (data.articles && data.articles.length > 0) {
                                newsCount = data.articles.length;
                                data.articles.forEach(article => {
                                    let publishDate = null;
                                    let publishTime = null;
                                    
                                    if (article.publishedAt) {
                                        const pubDate = new Date(article.publishedAt);
                                        publishDate = pubDate.toISOString().split('T')[0];
                                        publishTime = pubDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                                    }
                                    
                                    allResults.push({
                                        type: 'news',
                                        title: article.title,
                                        description: article.description,
                                        link: article.url,
                                        source: article.source?.name || 'News',
                                        date: publishDate,
                                        time: publishTime,
                                        author: article.author,
                                        metadata: {
                                            publishDate: publishDate,
                                            publishTime: publishTime,
                                            author: article.author,
                                            source: article.source?.name || 'News'
                                        }
                                    });
                                });
                            }
                            break;

                        case 'github':
                            if (data.items && data.items.length > 0) {
                                githubCount = data.items.length;
                                data.items.forEach(repo => {
                                    allResults.push({
                                        type: 'github',
                                        title: repo.full_name,
                                        description: repo.description,
                                        link: repo.html_url,
                                        source: 'GitHub',
                                        stars: repo.stargazers_count,
                                        language: repo.language
                                    });
                                });
                            }
                            break;

                        case 'reddit':
                            if (data.data && data.data.children) {
                                redditCount = data.data.children.length;
                                data.data.children.forEach(post => {
                                    const postData = post.data;
                                    allResults.push({
                                        type: 'reddit',
                                        title: postData.title,
                                        description: postData.selftext || `r/${postData.subreddit}`,
                                        link: postData.url.startsWith('http') ? postData.url : `https://reddit.com${postData.permalink}`,
                                        source: 'Reddit',
                                        subreddit: postData.subreddit,
                                        score: postData.score
                                    });
                                });
                            }
                            break;
                    }
                }
            });

            // Generate comprehensive results HTML
            const summaryHTML = `
                <div style="text-align: center; margin-bottom: 20px; padding: 15px; background: rgba(0, 255, 255, 0.1); border-radius: 10px;">
                    <h3 style="color: var(--cyber-blue); margin-bottom: 10px;">🚀 Comprehensive Search Results</h3>
                    <p style="color: var(--cyber-green); font-weight: bold;">
                        Found ${allResults.length} total results for "${query}"${location ? ` in ${location}` : ''}
                    </p>
                    <div style="display: flex; justify-content: center; gap: 15px; margin-top: 10px; flex-wrap: wrap;">
                        ${eventCount > 0 ? `<span style="color: var(--cyber-blue);">🎪 ${eventCount} Events</span>` : ''}
                        ${newsCount > 0 ? `<span style="color: var(--cyber-pink);">📰 ${newsCount} News</span>` : ''}
                        ${githubCount > 0 ? `<span style="color: var(--cyber-green);">💻 ${githubCount} GitHub</span>` : ''}
                        ${redditCount > 0 ? `<span style="color: var(--cyber-orange);">💬 ${redditCount} Reddit</span>` : ''}
                    </div>
                </div>
            `;

            if (allResults.length === 0) {
                resultsDiv.innerHTML = summaryHTML + '<p style="text-align: center; color: #666;">No results found across all platforms.</p>';
                return;
            }

            // Sort results by relevance/type
            allResults.sort((a, b) => {
                const typeOrder = { 'event': 1, 'news': 2, 'github': 3, 'reddit': 4 };
                return typeOrder[a.type] - typeOrder[b.type];
            });

            const resultItems = allResults.map(result => {
                const typeColors = {
                    'event': 'var(--cyber-blue)',
                    'news': 'var(--cyber-pink)',
                    'github': 'var(--cyber-green)',
                    'reddit': 'var(--cyber-orange)'
                };

                const typeIcons = {
                    'event': '🎪',
                    'news': '📰',
                    'github': '💻',
                    'reddit': '💬'
                };

                // Create unique ID for starring
                const resultId = result.link || `${result.type}-${result.title}-${result.date}`;
                const isStarred = isItemStarred(resultId);
                
                // Enhanced timing display
                let timeDisplay = '';
                if (result.date) {
                    const dateObj = new Date(result.date);
                    timeDisplay = `📅 ${dateObj.toLocaleDateString()}`;
                    
                    if (result.time) {
                        timeDisplay += ` • ⏰ ${result.time}`;
                        if (result.endTime) {
                            timeDisplay += ` - ${result.endTime}`;
                        }
                    }
                }

                return `
                    <div class="result-item" style="margin-bottom: 15px; padding: 15px; background: rgba(0, 0, 0, 0.3); border-left: 4px solid ${typeColors[result.type]}; position: relative;">
                        <div style="position: absolute; top: 12px; right: 12px; z-index: 10;">
                            <button class="star-btn ${isStarred ? 'starred' : ''}" onclick="toggleStar('${escapeForJS(resultId)}', '${encodeURIComponent(JSON.stringify({title: result.title, description: result.description, link: result.link, metadata: result.metadata}))}')" title="⭐ Star and add to Google Calendar" style="padding:6px 8px; border-radius:6px; background: rgba(0,255,255,0.2) !important; border:1px solid var(--cyber-blue) !important; color: var(--cyber-blue) !important; font-weight: bold !important; font-size: 0.9rem;">
                                ${isStarred ? '★ Starred' : '☆ Star'}
                            </button>
                        </div>
                        <div class="result-content" style="margin-right: 100px;">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                                <div style="flex: 1;">
                                    <div class="result-title" style="color: var(--cyber-blue); font-size: 1.1rem; margin-bottom: 8px; font-weight: bold;">${result.title}</div>
                                    <div style="display: flex; gap: 12px; align-items: center; margin-bottom: 10px; flex-wrap: wrap;">
                                        <span style="color: ${typeColors[result.type]}; font-size: 0.8rem; font-weight: bold; background: rgba(0,0,0,0.6); padding: 3px 8px; border-radius: 12px; border: 1px solid ${typeColors[result.type]};">
                                            ${typeIcons[result.type]} ${result.source}
                                        </span>
                                        ${timeDisplay ? `<span style="color: var(--cyber-green); font-size: 0.8rem; background: rgba(0,0,0,0.4); padding: 2px 6px; border-radius: 8px;">${timeDisplay}</span>` : ''}
                                        ${result.venue ? `<span style="color: var(--cyber-orange); font-size: 0.8rem; background: rgba(0,0,0,0.4); padding: 2px 6px; border-radius: 8px;">📍 ${result.venue}</span>` : ''}
                                        ${result.author ? `<span style="color: var(--cyber-pink); font-size: 0.8rem; background: rgba(0,0,0,0.4); padding: 2px 6px; border-radius: 8px;">✍️ ${result.author}</span>` : ''}
                                        ${result.stars ? `<span style="color: var(--cyber-green); font-size: 0.8rem; background: rgba(0,0,0,0.4); padding: 2px 6px; border-radius: 8px;">⭐ ${result.stars}</span>` : ''}
                                        ${result.score ? `<span style="color: var(--cyber-orange); font-size: 0.8rem; background: rgba(0,0,0,0.4); padding: 2px 6px; border-radius: 8px;">👍 ${result.score}</span>` : ''}
                                        ${result.language ? `<span style="color: var(--cyber-purple); font-size: 0.8rem; background: rgba(0,0,0,0.4); padding: 2px 6px; border-radius: 8px;">💻 ${result.language}</span>` : ''}
                                    </div>
                                </div>
                            </div>
                            ${result.link ? `
                                <div style="margin: 10px 0;">
                                    <a href="${result.link}" target="_blank" class="result-link" style="color: var(--cyber-green); text-decoration: none; font-size: 0.9rem; display: inline-flex; align-items: center; gap: 8px; background: rgba(0, 255, 0, 0.1); padding: 8px 12px; border-radius: 8px; border: 1px solid var(--cyber-green); transition: all 0.3s ease;">
                                        🔗 <span style="font-weight: bold;">View Source</span>
                                        <span style="font-size: 0.8rem; opacity: 0.8;">(${new URL(result.link).hostname})</span>
                                    </a>
                                </div>
                            ` : ''}
                            <div class="result-snippet" style="color: #ccc; font-size: 0.9rem; line-height: 1.5; margin-top: 10px;">${result.description || 'No description available'}</div>
                        </div>
                    </div>
                `;
            }).join('');

            resultsDiv.innerHTML = summaryHTML + resultItems;
            
            // Save to search history with correct counts
            saveComprehensiveSearchToHistory(query, location, searchMode, eventCount, newsCount, githubCount, redditCount, allResults);
        }

        // Enhanced search function
        async function searchEvents() {
            const location = document.getElementById('locationInput').value.trim();
            const genre = document.getElementById('genreSelect').value;
            const eventType = document.getElementById('eventTypeSelect').value;
            const timeframe = document.getElementById('timeframeSelect').value;
            const radius = document.getElementById('radiusInput').value || 25;
            
            if (!location) {
                alert('Please enter a location');
                return;
            }

            const resultsDiv = document.getElementById('eventsResults');
            resultsDiv.innerHTML = '<div class="loading">🔍 Scanning event networks...</div>';

            try {
                // Check if location contains "lubbock" to show TTU event websites
                const isLubbockSearch = location.toLowerCase().includes('lubbock');

                if (isLubbockSearch) {
                    // Show actual TTU websites with scrapable event information
                    const ttuEventSites = {
                        events: [
                            {
                                title: "TTU Athletics Events Calendar",
                                description: "Official Texas Tech University athletics events calendar with complete game schedules, times, and venue information.",
                                venue: "Various TTU Athletic Venues",
                                location: "Texas Tech University, Lubbock, TX",
                                date: "Ongoing",
                                time: "Various Times",
                                datetime: new Date().toISOString(),
                                url: "https://texastech.com/calendar",
                                source: "TTU Athletics",
                                price: "Varies",
                                category: "Sports",
                                scrapable: true
                            },
                            {
                                title: "TTU Student Activities & Events",
                                description: "Student activities calendar with campus events, student organization meetings, and social activities.",
                                venue: "Student Union Building & Campus",
                                location: "Texas Tech University, Lubbock, TX",
                                date: "Ongoing",
                                time: "Various Times", 
                                datetime: new Date().toISOString(),
                                url: "https://www.depts.ttu.edu/studentactivities/calendar/",
                                source: "TTU Student Activities",
                                price: "Free/Varies",
                                category: "Student Life",
                                scrapable: true
                            },
                            {
                                title: "TTU Career Services Events",
                                description: "Career fairs, networking events, workshops, and employer information sessions with dates and locations.",
                                venue: "Various Campus Locations",
                                location: "Texas Tech University, Lubbock, TX",
                                date: "Ongoing",
                                time: "Various Times",
                                datetime: new Date().toISOString(),
                                url: "https://www.depts.ttu.edu/careercenter/events/",
                                source: "TTU Career Services",
                                price: "Free",
                                category: "Professional",
                                scrapable: true
                            },
                            {
                                title: "TTU Research Events & Symposiums",
                                description: "Research presentations, symposiums, and academic conferences with detailed scheduling information.",
                                venue: "Various Academic Buildings",
                                location: "Texas Tech University, Lubbock, TX",
                                date: "Ongoing",
                                time: "Various Times",
                                datetime: new Date().toISOString(),
                                url: "https://www.depts.ttu.edu/research/events/",
                                source: "TTU Research",
                                price: "Free",
                                category: "Academic",
                                scrapable: true
                            },
                            {
                                title: "TTU Arts & Performance Events",
                                description: "Theater performances, concerts, art exhibitions, and cultural events with ticketing and scheduling details.",
                                venue: "Maedgen Theatre & Campus Venues",
                                location: "Texas Tech University, Lubbock, TX",
                                date: "Ongoing",
                                time: "Various Times",
                                datetime: new Date().toISOString(),
                                url: "https://www.depts.ttu.edu/theatrearts/events/",
                                source: "TTU Arts",
                                price: "Varies",
                                category: "Arts",
                                scrapable: true
                            },
                            {
                                title: "TTU Library Events & Workshops",
                                description: "Library workshops, study sessions, and academic support events with registration information.",
                                venue: "University Library",
                                location: "Texas Tech University Library, Lubbock, TX",
                                date: "Ongoing",
                                time: "Various Times",
                                datetime: new Date().toISOString(),
                                url: "https://www.library.ttu.edu/events/",
                                source: "TTU Library",
                                price: "Free",
                                category: "Academic",
                                scrapable: true
                            },
                            {
                                title: "TTU Engineering Events",
                                description: "Engineering college events, tech talks, career fairs, and industry networking events.",
                                venue: "Whitacre College of Engineering",
                                location: "Texas Tech University, Lubbock, TX",
                                date: "Ongoing",
                                time: "Various Times",
                                datetime: new Date().toISOString(),
                                url: "https://www.depts.ttu.edu/coe/events/",
                                source: "TTU Engineering",
                                price: "Free/Varies",
                                category: "Technology",
                                scrapable: true
                            },
                            {
                                title: "TTU Official Events Calendar",
                                description: "Main university events calendar with all campus activities, deadlines, and important dates.",
                                venue: "Texas Tech University Campus",
                                location: "Texas Tech University, Lubbock, TX",
                                date: "Ongoing",
                                time: "Various Times",
                                datetime: new Date().toISOString(),
                                url: "https://www.ttu.edu/calendar/",
                                source: "TTU Official",
                                price: "Varies",
                                category: "University",
                                scrapable: true
                            }
                        ],
                        metadata: {
                            location: location,
                            total: 8,
                            source: "Texas Tech University Event Websites",
                            note: "These are actual TTU websites that contain scrapable event information with dates, times, and locations."
                        }
                    };
                    
                    displayEventResults(ttuEventSites);
                    await saveEventSearch(ttuEventSites);
                    return;
                }

                // Enhanced API now uses GET with query parameters
                const queryParams = new URLSearchParams({
                    location: location,
                    genre: genre,
                    timeframe: timeframe
                });

                const response = await fetch(`/api/search-events?${queryParams}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('Search results:', data); // Debug log
                
                // Display results directly in eventsResults div
                displayEventResults(data);
                
                // Save the search
                await saveEventSearch(data);
            } catch (error) {
                console.error('Event search error:', error);
                resultsDiv.innerHTML = '<div style="color: var(--cyber-pink); text-align: center;">Event search failed. Check network connection.</div>';
            }
        }

        // Simple event results display function
        function displayEventResults(data) {
            const resultsDiv = document.getElementById('eventsResults');
            const events = data.events || data.results || [];
            const location = data.metadata?.location || data.location || 'Unknown Location';
            
            if (!events || events.length === 0) {
                resultsDiv.innerHTML = `<p style="text-align: center; color: #666;">No events found for "${location}"</p>`;
                return;
            }

            const eventsHTML = `
                <div style="text-align: center; margin-bottom: 20px; padding: 15px; background: rgba(0, 255, 255, 0.1); border-radius: 10px;">
                    <p style="color: var(--cyber-blue); font-weight: bold;">
                        🎪 Found ${events.length} events in ${location}
                    </p>
                </div>
                ${events.map((event, index) => {
                    const title = event.title || event.name || `Event ${index + 1}`;
                    const description = event.description || event.summary || 'No description available';
                    const venue = event.venue || event.location || 'Venue TBD';
                    const date = event.date || event.start_date || event.datetime || 'Date TBD';
                    const time = event.time || event.start_time || '';
                    const link = event.url || event.link || '#';
                    const source = event.source || 'Unknown Source';
                    
                    return `
                        <div class="history-item event-card" style="margin-bottom: 15px; padding: 15px; background: rgba(0, 0, 0, 0.3); border-left: 4px solid var(--cyber-blue); cursor: pointer; position: relative; transition: all 0.3s ease;" 
                             onclick="openEventSource('${link.replace(/'/g, "\\'")}', '${title.replace(/'/g, "\\'")}')">
                            <div class="history-content">
                                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                                    <div style="flex: 1;">
                                        <div class="history-query" style="color: var(--cyber-blue); font-size: 1rem; margin-bottom: 5px; font-weight: bold;">${title}</div>
                                        <div style="display: flex; gap: 15px; align-items: center; margin-bottom: 8px; flex-wrap: wrap;">
                                            <span style="color: var(--cyber-green); font-size: 0.85rem;">📅 ${date}</span>
                                            ${time ? `<span style="color: var(--cyber-green); font-size: 0.85rem;">🕐 ${time}</span>` : ''}
                                            <span style="color: var(--cyber-orange); font-size: 0.85rem;">📍 ${venue}</span>
                                            ${event.price ? `<span style="color: var(--cyber-pink); font-size: 0.85rem;">💰 ${event.price}</span>` : ''}
                                            <span style="color: #888; font-size: 0.8rem;">🔗 ${source}</span>
                                        </div>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 10px;">
                                        <button class="star-btn" onclick="toggleEventWish(event, {
                                            title: '${title.replace(/'/g, "\\'")}',
                                            description: '${description.replace(/'/g, "\\'")}',
                                            date: '${date}',
                                            time: '${time}',
                                            location: '${venue.replace(/'/g, "\\'")}',
                                            url: '${link.replace(/'/g, "\\'")}',
                                            source: '${source.replace(/'/g, "\\'")}',
                                            category: '${event.category || 'general'}'
                                        })" style="
                                            background: transparent; 
                                            border: 2px solid var(--cyber-blue); 
                                            color: var(--cyber-blue); 
                                            font-size: 1.2rem; 
                                            width: 40px; 
                                            height: 40px; 
                                            border-radius: 50%; 
                                            cursor: pointer; 
                                            display: flex; 
                                            align-items: center; 
                                            justify-content: center;
                                            transition: all 0.3s ease;
                                        " onmouseover="this.style.background='var(--cyber-blue)'; this.style.color='black';" 
                                           onmouseout="this.style.background='transparent'; this.style.color='var(--cyber-blue)';">
                                            ⭐
                                        </button>
                                    </div>
                                </div>
                                <div style="color: #ccc; font-size: 0.9rem; line-height: 1.4; margin-bottom: 10px;">${description}</div>
                                ${link !== '#' ? `<div style="color: var(--cyber-green); font-size: 0.8rem; opacity: 0.8;">Click to view source →</div>` : ''}
                            </div>
                        </div>
                    `;
                }).join('')}
            `;

            resultsDiv.innerHTML = eventsHTML;
        }

        // Real-time event discovery function
        async function discoverEventsNow() {
            const location = document.getElementById('locationInput').value.trim();
            const genre = document.getElementById('genreInput').value.trim() || 'events';
            
            if (!location) {
                alert('Please enter a location for real-time discovery');
                return;
            }

            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<div class="loading">🔍 Discovering events happening now...</div>';

            try {
                // Use the working enhanced API endpoint
                const queryParams = new URLSearchParams({
                    location: location,
                    genre: genre,
                    timeframe: 'immediate'
                });

                const response = await fetch(`/api/search-events?${queryParams}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('Discover Now results:', data); // Debug log
                
                // Store the data globally and display in tabs
                currentEventsData = data;
                displaySeparatedResults(data);
                
                // Save the discovery
                await saveEventSearch(data);
            } catch (error) {
                console.error('Real-time discovery error:', error);
                resultsDiv.innerHTML = '<div style="color: var(--cyber-pink); text-align: center;">Real-time discovery failed. Check network connection.</div>';
            }
        }

        // Display enhanced search results
        function displayEnhancedResults(data) {
            const resultsDiv = document.getElementById('results');
            
            // Enhanced server returns 'events' not 'results'
            const events = data.events || data.results || [];
            const location = data.metadata?.location || data.location || 'Unknown Location';
            const genre = data.metadata?.genre || data.genre || '';
            
            console.log('Displaying results:', { events: events.length, data }); // Debug log
            
            if (!events || events.length === 0) {
                resultsDiv.innerHTML = `
                    <div style="text-align: center; color: #666;">
                        <p>No events found for "${location}"</p>
                        <p style="font-size: 0.9rem; margin-top: 10px;">Try a different location or genre.</p>
                    </div>`;
                return;
            }

            const header = `
                <div style="text-align: center; margin-bottom: 20px; padding: 15px; background: rgba(0, 255, 255, 0.1); border-radius: 10px;">
                    <p style="color: var(--cyber-blue); font-weight: bold;">
                        📍 Found ${data.totalFound || events.length} events in ${location}
                        ${genre && genre !== 'any' ? ` • ${genre}` : ''}
                    </p>
                    <p style="color: #888; font-size: 0.9rem;">
                        API Sources: ${data.apiSources ? data.apiSources.join(', ') : 'Multiple APIs'} | Quality: ${data.searchQuality || 'Enhanced'}
                    </p>
                </div>
            `;

            // Display the events using the enhanced format
            const eventsHTML = events.slice(0, 20).map(event => `
                <div class="result-item" style="background: rgba(0, 255, 255, 0.05); border: 1px solid var(--cyber-blue); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                    <div class="result-header" style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                        <h3 style="color: var(--cyber-blue); margin: 0; flex-grow: 1;">${event.title}</h3>
                        <div style="text-align: right; margin-left: 15px;">
                            <span style="background: var(--cyber-pink); color: black; padding: 2px 8px; border-radius: 4px; font-size: 0.8rem; font-weight: bold;">${event.source || 'API'}</span>
                            ${event.category ? `<br><span style="color: var(--cyber-orange); font-size: 0.8rem;">${event.category}</span>` : ''}
                        </div>
                    </div>
                    <p style="color: #ccc; margin: 10px 0;">${event.description || 'Event details coming soon'}</p>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                        <div>
                            <span style="color: var(--cyber-green);">📍 ${event.location || location}</span>
                            ${event.date ? `<br><span style="color: var(--cyber-orange);">🗓️ ${new Date(event.date).toLocaleDateString()}</span>` : ''}
                        </div>
                        <div style="text-align: right;">
                            ${event.price ? `<span style="color: var(--cyber-yellow);">💰 ${event.price}</span><br>` : ''}
                            ${event.url ? `<a href="${event.url}" target="_blank" style="color: var(--cyber-pink); text-decoration: none;">View Details →</a>` : ''}
                        </div>
                    </div>
                </div>
            `).join('');

            resultsDiv.innerHTML = header + eventsHTML;
        }

        // Display real-time discovery results
        function displayRealTimeResults(data) {
            const resultsDiv = document.getElementById('results');
            
            if (!data.results || data.results.length === 0) {
                resultsDiv.innerHTML = `
                    <div style="text-align: center; color: #666;">
                        <p>No immediate events found in "${data.location}"</p>
                        <p style="font-size: 0.9rem; margin-top: 10px;">Try expanding your search radius or check back later.</p>
                    </div>`;
                return;
            }

            const header = `
                <div style="text-align: center; margin-bottom: 20px; padding: 15px; background: rgba(255, 107, 0, 0.2); border-radius: 10px; border: 2px solid var(--cyber-orange);">
                    <p style="color: var(--cyber-orange); font-weight: bold; font-size: 1.1rem;">
                        🚨 REAL-TIME DISCOVERY: ${data.location}
                    </p>
                    <p style="color: var(--cyber-blue);">
                        Found ${data.summary.total} events • Immediate: ${data.summary.immediate} • Tonight: ${data.summary.tonight}
                    </p>
                    <p style="color: #888; font-size: 0.9rem;">
                        Searched ${data.meta.queriesExecuted} sources • Confidence: ${(data.summary.avgConfidence * 100).toFixed(0)}%
                    </p>
                </div>
            `;

            // Group results by time relevance
            const categorizedHTML = generateRealTimeCategorizedHTML(data.categorized, data.summary);

            resultsDiv.innerHTML = header + categorizedHTML;
        }

        // Generate categorized HTML for enhanced results
        function generateCategorizedHTML(categorized, allResults) {
            let html = '';
            
            const categories = [
                { key: 'immediate', title: '🔥 Happening Now', color: 'var(--cyber-orange)' },
                { key: 'upcoming', title: '⚡ Coming Soon', color: 'var(--cyber-pink)' },
                { key: 'general', title: '📅 General Events', color: 'var(--cyber-blue)' },
                { key: 'reference', title: '📚 Event Directories', color: 'var(--cyber-purple)' }
            ];

            // Show categorized results if available
            if (categorized && Object.keys(categorized).length > 0) {
                categories.forEach(category => {
                    const events = categorized[category.key] || [];
                    if (events.length > 0) {
                        html += `
                            <div style="margin-bottom: 25px;">
                                <h3 style="color: ${category.color}; margin-bottom: 15px; font-family: 'Orbitron', monospace; border-bottom: 2px solid ${category.color}; padding-bottom: 5px;">
                                    ${category.title} (${events.length})
                                </h3>
                                ${events.map(event => generateEventHTML(event)).join('')}
                            </div>
                        `;
                    }
                });
            } else {
                // Fallback to all results
                html = allResults.map(event => generateEventHTML(event)).join('');
            }

            return html;
        }

        // Generate real-time categorized HTML
        function generateRealTimeCategorizedHTML(categorized, summary) {
            let html = '';
            
            const categories = [
                { key: 'immediate', title: '🚨 RIGHT NOW', color: 'var(--cyber-orange)', urgent: true },
                { key: 'tonight', title: '🌙 TONIGHT', color: 'var(--cyber-pink)', urgent: true },
                { key: 'thisWeek', title: '📅 THIS WEEK', color: 'var(--cyber-blue)', urgent: false },
                { key: 'ongoing', title: '🔄 ONGOING', color: 'var(--cyber-green)', urgent: false }
            ];

            categories.forEach(category => {
                const events = categorized[category.key] || [];
                if (events.length > 0) {
                    html += `
                        <div style="margin-bottom: 25px;">
                            <h3 style="color: ${category.color}; margin-bottom: 15px; font-family: 'Orbitron', monospace; border-bottom: 2px solid ${category.color}; padding-bottom: 5px; ${category.urgent ? 'animation: pulse 2s infinite;' : ''}">
                                ${category.title} (${events.length})
                            </h3>
                            ${events.map(event => generateEventHTML(event, category.urgent)).join('')}
                        </div>
                    `;
                }
            });

            return html;
        }

        // Generate individual event HTML
        function generateEventHTML(event, isUrgent = false) {
            const urgencyBorder = isUrgent ? '3px solid var(--cyber-orange)' : '1px solid var(--cyber-blue)';
            const urgencyGlow = isUrgent ? 'box-shadow: 0 0 15px rgba(255, 107, 0, 0.5);' : '';
            
            return `
                <div class="result-item" style="border-left: 4px solid ${getEventTypeColor(event.eventType)}; border: ${urgencyBorder}; ${urgencyGlow}">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                        <div class="result-title" style="flex: 1;">${event.title || 'Event'}</div>
                        <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                            <span style="background: ${getEventTypeColor(event.eventType)}; color: black; padding: 2px 6px; border-radius: 10px; font-size: 0.7rem; font-weight: bold;">
                                ${event.source}
                            </span>
                            <span style="background: var(--cyber-purple); color: white; padding: 2px 6px; border-radius: 10px; font-size: 0.7rem;">
                                ${event.eventType}
                            </span>
                            ${event.urgency === 'immediate' ? '<span style="background: var(--cyber-orange); color: black; padding: 2px 6px; border-radius: 10px; font-size: 0.7rem; animation: pulse 1s infinite;">NOW</span>' : ''}
                            ${event.confidence ? `<span style="background: var(--cyber-green); color: black; padding: 2px 6px; border-radius: 10px; font-size: 0.7rem;">${(event.confidence * 100).toFixed(0)}%</span>` : ''}
                        </div>
                    </div>
                    <a href="${event.url}" target="_blank" class="result-link">${event.url}</a>
                    <div class="result-snippet">${event.description}</div>
                    <div style="display: flex; gap: 15px; margin-top: 8px; font-size: 0.8rem;">
                        ${event.category ? `<span style="color: var(--cyber-green);">📂 ${event.category}</span>` : ''}
                        ${event.extractedDate ? `<span style="color: var(--cyber-blue);">📅 ${event.extractedDate}</span>` : ''}
                        ${event.extractedTime ? `<span style="color: var(--cyber-pink);">🕐 ${event.extractedTime}</span>` : ''}
                        ${event.urgency ? `<span style="color: var(--cyber-orange);">⚡ ${event.urgency}</span>` : ''}
                    </div>
                </div>
            `;
        }

        // Get color for event type
        function getEventTypeColor(type) {
            const colors = {
                'ticketed': '#ff6b00',
                'community': '#00ff41', 
                'social': '#ff0080',
                'general': '#00ffff'
            };
            return colors[type] || '#00ffff';
        }

        // Save event search
        async function saveEventSearch(searchData) {
            try {
                await fetch('/api/save-search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        query: `${searchData.location} - ${searchData.genre || 'any'} - ${searchData.eventType || 'any'}`,
                        results: searchData.results
                    })
                });
            } catch (error) {
                console.error('Failed to save search:', error);
            }
        }

        // Save comprehensive search to history with correct counts
        async function saveComprehensiveSearchToHistory(query, location, searchMode, eventCount, newsCount, githubCount, redditCount, allResults) {
            try {
                // Save to localStorage for immediate display
                const searches = getSearchHistory();
                const newSearch = {
                    id: Date.now(),
                    query: query,
                    location: location || '',
                    searchMode: searchMode || 'auto',
                    timestamp: new Date().toISOString(),
                    eventsFound: eventCount,
                    newsFound: newsCount,
                    githubFound: githubCount || 0,
                    redditFound: redditCount || 0,
                    totalResults: eventCount + newsCount + (githubCount || 0) + (redditCount || 0)
                };
                
                searches.unshift(newSearch);
                
                // Keep only latest 50 searches
                if (searches.length > 50) {
                    searches.splice(50);
                }
                
                localStorage.setItem('prospectorSearchHistory', JSON.stringify(searches));
                loadSearchHistory();
                updateSearchStats();

                // Save to database if user is authenticated
                if (currentUser) {
                    console.log('🔐 Attempting to save search for authenticated user:', currentUser.username);
                    try {
                        // Clean and format results for database storage
                        const formattedResults = (allResults || []).map(result => ({
                            title: result.title || 'Untitled',
                            description: result.description || '',
                            url: result.link || result.url || '', // Use link or url, fallback to empty string
                            source: result.source || 'Unknown',
                            metadata: {
                                type: result.type,
                                date: result.date,
                                venue: result.venue,
                                stars: result.stars,
                                score: result.score,
                                subreddit: result.subreddit,
                                language: result.language,
                                author: result.author
                            }
                        }));

                        const response = await fetch('/api/save-search', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            credentials: 'include',
                            body: JSON.stringify({
                                query: query,
                                location: location || '',
                                searchMode: searchMode || 'auto',
                                results: formattedResults,
                                resultCounts: {
                                    events: eventCount,
                                    news: newsCount,
                                    github: githubCount || 0,
                                    reddit: redditCount || 0,
                                    total: eventCount + newsCount + (githubCount || 0) + (redditCount || 0)
                                }
                            })
                        });
                        
                        if (response.ok) {
                            console.log(`✅ Search saved to database for user: ${currentUser.username}`);
                        } else {
                            console.log('❌ Failed to save search to database');
                        }
                    } catch (dbError) {
                        console.log('📝 Database save failed:', dbError.message);
                    }
                } else {
                    console.log('👤 Guest user - search saved to localStorage only. currentUser:', currentUser);
                }

            } catch (error) {
                console.error('Failed to save search to history:', error);
            }
        }

        // Load nearby events using geolocation
        async function loadNearbyEvents() {
            if (!navigator.geolocation) {
                alert('Geolocation not supported by your browser');
                return;
            }

            const resultsDiv = document.getElementById('eventsResults');
            resultsDiv.innerHTML = '<div class="loading">📍 Getting your location...</div>';

            navigator.geolocation.getCurrentPosition(async (position) => {
                const lat = position.coords.latitude;
                const lon = position.coords.longitude;
                
                // Try to get a readable address using reverse geocoding
                try {
                    const response = await fetch(`https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${lat}&longitude=${lon}&localityLanguage=en`);
                    const data = await response.json();
                    const address = data.city && data.countryName ? `${data.city}, ${data.countryName}` : `${lat.toFixed(2)}, ${lon.toFixed(2)}`;
                    document.getElementById('locationInput').value = address;
                } catch (error) {
                    // Fallback to coordinates if geocoding fails
                    document.getElementById('locationInput').value = `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
                }
                
                resultsDiv.innerHTML = '<div class="loading">🔍 Finding nearby events...</div>';
                await searchEvents();
            }, (error) => {
                resultsDiv.innerHTML = '<div style="color: var(--cyber-pink); text-align: center;">Location access denied. Please enter location manually.</div>';
            });
        }

        // Clear results
        function clearResults() {
            document.getElementById('eventsResults').innerHTML = '<p style="text-align: center; color: #666;">Enter location and preferences to discover live events...</p>';
            document.getElementById('locationInput').value = '';
            document.getElementById('genreSelect').value = '';
            document.getElementById('eventTypeSelect').value = '';
            document.getElementById('timeframeSelect').value = 'upcoming';
            document.getElementById('radiusInput').value = '25';
        }

        // Handle Enter key for location input
        document.getElementById('locationInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchEvents();
            }
        });

        // Handle Enter key for radius input
        document.getElementById('radiusInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchEvents();
            }
        });

        // New function to display results separated by events and news
        function displaySeparatedResults(data) {
            const events = data.events || data.results || [];
            const location = data.metadata?.location || data.location || 'Unknown Location';
            
            console.log('Displaying separated results:', { events: events.length, activeTab: currentActiveTab });
            
            if (!events || events.length === 0) {
                const message = `<p style="text-align: center; color: #666;">No ${currentActiveTab} found for "${location}"</p>`;
                document.getElementById(currentActiveTab + 'Results').innerHTML = message;
                return;
            }

            // Get sorting and filtering preferences
            const sortBy = document.getElementById('sortBy').value;
            const focus = document.getElementById('eventFocus').value;

            // Separate events from news
            const liveEvents = events.filter(event => 
                event.type !== 'news-event' && 
                event.type !== 'news-style' &&
                event.source !== 'NewsAPI'
            );
            
            const newsEvents = events.filter(event => 
                event.type === 'news-event' || 
                event.type === 'news-style' ||
                event.source === 'NewsAPI'
            );

            // Apply sorting and filtering
            const sortedLiveEvents = sortEvents(filterEvents(liveEvents, focus), sortBy);
            const sortedNewsEvents = sortEvents(filterEvents(newsEvents, focus), sortBy);

            // Display based on active tab
            if (currentActiveTab === 'events') {
                displayEventsTab(sortedLiveEvents, data);
            } else {
                displayNewsTab(sortedNewsEvents, data);
            }
        }

        // Display live events tab
        function displayEventsTab(events, originalData) {
            const location = originalData.metadata?.location || originalData.location || 'Unknown Location';
            const genre = originalData.metadata?.genre || originalData.genre || '';

            const header = `
                <div style="text-align: center; margin-bottom: 20px; padding: 15px; background: rgba(0, 255, 255, 0.1); border-radius: 10px;">
                    <p style="color: var(--cyber-blue); font-weight: bold;">
                        🎪 Found ${events.length} live events in ${location}
                        ${genre ? ` • ${genre}` : ''}
                    </p>
                    <p style="color: #888; font-size: 0.9rem;">
                        Live Events • Sorted by ${document.getElementById('sortBy').value}
                    </p>
                </div>
            `;

            const eventsHTML = events.slice(0, 20).map(event => `
                <div class="result-item" style="background: rgba(0, 255, 255, 0.05); border: 1px solid var(--cyber-blue); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                    <div class="result-header" style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                        <h3 style="color: var(--cyber-blue); margin: 0; flex-grow: 1;">${event.title}</h3>
                        <div style="text-align: right; margin-left: 15px;">
                            <span style="background: var(--cyber-green); color: black; padding: 2px 8px; border-radius: 4px; font-size: 0.8rem; font-weight: bold;">${event.source || 'EVENT'}</span>
                            ${event.category ? `<br><span style="color: var(--cyber-orange); font-size: 0.8rem;">${event.category}</span>` : ''}
                            ${event.isFree ? `<br><span style="color: var(--cyber-green); font-size: 0.8rem;">FREE</span>` : ''}
                        </div>
                    </div>
                    <p style="color: #ccc; margin: 10px 0;">${event.description || 'Event details coming soon'}</p>
                    
                    <!-- Enhanced Location Information -->
                    <div style="background: rgba(0, 255, 0, 0.1); border: 1px solid var(--cyber-green); border-radius: 5px; padding: 10px; margin: 10px 0;">
                        ${event.venue ? `<div style="color: var(--cyber-green); font-weight: bold; margin-bottom: 5px;">🏢 ${event.venue}</div>` : ''}
                        <div style="color: var(--cyber-green); display: flex; align-items: center;">
                            <span style="margin-right: 8px;">📍</span>
                            <span style="font-family: monospace;">${event.address || event.location || location}</span>
                        </div>
                        ${event.coordinates ? `
                            <div style="color: #888; font-size: 0.8rem; margin-top: 5px;">
                                �️ ${event.coordinates.lat.toFixed(4)}, ${event.coordinates.lng.toFixed(4)}
                                <a href="https://maps.google.com/?q=${event.coordinates.lat},${event.coordinates.lng}" target="_blank" style="color: var(--cyber-pink); margin-left: 10px;">View on Maps</a>
                            </div>
                        ` : ''}
                    </div>
                    
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                        <div>
                            ${event.date ? `<span style="color: var(--cyber-orange);">🗓️ ${new Date(event.date).toLocaleDateString()} at ${new Date(event.date).toLocaleTimeString()}</span><br>` : ''}
                            ${event.attendees ? `<span style="color: var(--cyber-blue);">👥 ${event.attendees} attending</span>` : ''}
                        </div>
                        <div style="text-align: right;">
                            ${event.price && event.price !== 'Free' ? `<span style="color: var(--cyber-yellow);">💰 ${event.price}</span><br>` : ''}
                            ${event.url ? `<a href="${event.url}" target="_blank" style="color: var(--cyber-pink); text-decoration: none;">View Event →</a>` : ''}
                        </div>
                    </div>
                </div>
            `).join('');

            document.getElementById('eventsResults').innerHTML = header + eventsHTML;
        }

        // Display news tab
        function displayNewsTab(newsEvents, originalData) {
            const location = originalData.metadata?.location || originalData.location || 'Unknown Location';

            const header = `
                <div style="text-align: center; margin-bottom: 20px; padding: 15px; background: rgba(255, 165, 0, 0.1); border-radius: 10px;">
                    <p style="color: var(--cyber-orange); font-weight: bold;">
                        📰 Found ${newsEvents.length} event news articles for ${location}
                    </p>
                    <p style="color: #888; font-size: 0.9rem;">
                        Event News & Announcements • Sorted by ${document.getElementById('sortBy').value}
                    </p>
                </div>
            `;

            const newsHTML = newsEvents.slice(0, 15).map(article => `
                <div class="result-item" style="background: rgba(255, 165, 0, 0.05); border: 1px solid var(--cyber-orange); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                    <div class="result-header" style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                        <h3 style="color: var(--cyber-orange); margin: 0; flex-grow: 1;">${article.title}</h3>
                        <div style="text-align: right; margin-left: 15px;">
                            <span style="background: var(--cyber-orange); color: black; padding: 2px 8px; border-radius: 4px; font-size: 0.8rem; font-weight: bold;">NEWS</span>
                            ${article.publisher ? `<br><span style="color: var(--cyber-blue); font-size: 0.8rem;">${article.publisher}</span>` : ''}
                        </div>
                    </div>
                    <p style="color: #ccc; margin: 10px 0;">${article.description || 'Event news and announcements'}</p>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                        <div>
                            <span style="color: var(--cyber-green);">📍 ${article.location || location}</span>
                            ${article.date ? `<br><span style="color: var(--cyber-orange);">📅 ${new Date(article.date).toLocaleDateString()}</span>` : ''}
                        </div>
                        <div style="text-align: right;">
                            ${article.url ? `<a href="${article.url}" target="_blank" style="color: var(--cyber-pink); text-decoration: none;">Read Article →</a>` : ''}
                        </div>
                    </div>
                </div>
            `).join('');

            document.getElementById('newsResults').innerHTML = header + newsHTML;
        }

        // Sidebar Functions
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const burger = document.querySelector('.burger-menu');
            const overlay = document.querySelector('.sidebar-overlay');
            
            sidebar.classList.toggle('open');
            burger.classList.toggle('open');
            overlay.classList.toggle('open');
            
            if (sidebar.classList.contains('open')) {
                loadSearchHistory();
                updateStats();
            }
        }

        function closeSidebar() {
            const sidebar = document.getElementById('sidebar');
            const burger = document.querySelector('.burger-menu');
            const overlay = document.querySelector('.sidebar-overlay');
            
            sidebar.classList.remove('open');
            burger.classList.remove('open');
            overlay.classList.remove('open');
        }

        // Search History Management
        function saveSearch(query, eventsCount, newsCount) {
            const searches = getSearchHistory();
            const newSearch = {
                id: Date.now(),
                query: query,
                eventsCount: eventsCount,
                newsCount: newsCount,
                date: new Date().toISOString(),
                timestamp: Date.now()
            };
            
            searches.unshift(newSearch);
            
            // Keep only last 50 searches
            if (searches.length > 50) {
                searches.splice(50);
            }
            
            localStorage.setItem('prospectorSearchHistory', JSON.stringify(searches));
        }

        function getSearchHistory() {
            const history = localStorage.getItem('prospectorSearchHistory');
            return history ? JSON.parse(history) : [];
        }

        // Favorites management functions
        async function getFavorites() {
            let allFavorites = [];
            
            // Get local favorites from localStorage
            const starredItems = localStorage.getItem('prospectorStarred');
            if (starredItems) {
                try {
                    const items = JSON.parse(starredItems);
                    const localFavorites = Object.keys(items).map(id => ({
                        id: id,
                        ...items[id].meta,
                        starredAt: items[id].starredAt,
                        serverId: items[id].serverId,
                        source: 'local'
                    }));
                    allFavorites = [...localFavorites];
                } catch (error) {
                    console.warn('Error parsing local favorites:', error);
                }
            }
            
            // If user is authenticated, also get server favorites
            if (currentUser) {
                try {
                    const response = await fetch('/api/user/wishes', {
                        credentials: 'include'
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        const serverFavorites = (data.wishes || []).map(wish => ({
                            id: wish._id,
                            title: wish.eventTitle,
                            description: wish.eventDescription,
                            link: wish.eventUrl,
                            date: wish.eventDate,
                            time: wish.eventTime,
                            location: wish.eventLocation,
                            starredAt: wish.createdAt,
                            serverId: wish._id,
                            source: 'server'
                        }));
                        
                        // Merge server favorites, avoiding duplicates
                        const existingIds = new Set(allFavorites.map(f => f.serverId).filter(Boolean));
                        const newServerFavorites = serverFavorites.filter(sf => !existingIds.has(sf.id));
                        allFavorites = [...allFavorites, ...newServerFavorites];
                    }
                } catch (error) {
                    console.warn('Error fetching server favorites:', error);
                }
            }
            
            return allFavorites;
        }

        // Synchronous version for backwards compatibility
        function getFavoritesSync() {
            const starredItems = localStorage.getItem('prospectorStarred');
            if (!starredItems) return [];
            
            const items = JSON.parse(starredItems);
            return Object.keys(items).map(id => ({
                id: id,
                ...items[id].meta,
                starredAt: items[id].starredAt,
                serverId: items[id].serverId
            }));
        }

        function saveFavorites(favorites) {
            const items = {};
            favorites.forEach(fav => {
                items[fav.id] = {
                    meta: {
                        title: fav.title,
                        description: fav.description,
                        link: fav.link,
                        date: fav.date,
                        time: fav.time,
                        location: fav.location,
                        source: fav.source
                    },
                    starredAt: fav.starredAt,
                    serverId: fav.serverId
                };
            });
            localStorage.setItem('prospectorStarred', JSON.stringify(items));
        }

        // Newsletter preview generation
        async function generateNewsletterPreview() {
            const searchHistory = getSearchHistory();
            const favorites = await getFavorites();
            const eventTracking = JSON.parse(localStorage.getItem('eventTracking') || '{}');

            // Create newsletter modal
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 800px; max-height: 85vh; overflow-y: auto;">
                    <span class="close" onclick="this.parentElement.parentElement.remove()">&times;</span>
                    <h2 style="color: var(--cyber-green); text-align: center; margin-bottom: 25px;">📧 Your Personalized Newsletter Preview</h2>
                    
                    <div id="newsletterPreviewContainer">
                        <div style="background: rgba(0, 255, 255, 0.05); padding: 20px; border-radius: 12px; border: 1px solid rgba(0, 255, 255, 0.2);">
                            <h3 style="color: var(--cyber-blue); margin-bottom: 15px;">🎯 This Week's Highlights</h3>
                            
                            <div style="margin-bottom: 20px;">
                                <h4 style="color: var(--cyber-green); margin-bottom: 10px;">📅 Your Upcoming Events</h4>
                                ${favorites.length > 0 ? favorites.slice(0, 3).map(fav => `
                                    <div style="margin: 8px 0; padding: 8px; background: rgba(0, 255, 0, 0.1); border-radius: 6px;">
                                        <strong>${fav.title}</strong>
                                        ${fav.date ? `<br><small>📅 ${fav.date}</small>` : ''}
                                        ${fav.location ? `<br><small>📍 ${fav.location}</small>` : ''}
                                    </div>
                                `).join('') : '<p style="color: #999;">No starred events yet. Star some events to see recommendations!</p>'}
                            </div>

                            <div style="margin-bottom: 20px;">
                                <h4 style="color: var(--cyber-orange); margin-bottom: 10px;">🔍 Based on Your Searches</h4>
                                ${searchHistory.length > 0 ? `
                                    <p style="color: #ccc;">You've been exploring: ${searchHistory.slice(0, 3).map(s => s.query).join(', ')}</p>
                                    <p style="color: var(--cyber-blue); font-size: 0.9rem;">We'll keep you updated on events matching these interests!</p>
                                ` : '<p style="color: #999;">No search history yet. Start searching to get personalized recommendations!</p>'}
                            </div>

                            <div style="margin-bottom: 20px;">
                                <h4 style="color: var(--cyber-pink); margin-bottom: 10px;">💡 Personalized Recommendations</h4>
                                <div style="background: rgba(255, 0, 128, 0.1); padding: 10px; border-radius: 6px;">
                                    <p>🎪 Community Art Festival - This Weekend</p>
                                    <p>🎵 Local Jazz Night - Friday 8PM</p>
                                    <p>🍕 Food Truck Rally - Sunday 12PM</p>
                                    <small style="color: #999;">* Based on your search patterns and favorites</small>
                                </div>
                            </div>

                            <div style="margin-bottom: 20px;">
                                <h4 style="color: var(--cyber-purple); margin-bottom: 10px;">📊 Your Activity Summary</h4>
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                                    <div style="background: rgba(139, 0, 255, 0.1); padding: 10px; border-radius: 6px; text-align: center;">
                                        <strong style="color: var(--cyber-purple);">${searchHistory.length}</strong>
                                        <br><small>Searches This Month</small>
                                    </div>
                                    <div style="background: rgba(255, 0, 128, 0.1); padding: 10px; border-radius: 6px; text-align: center;">
                                        <strong style="color: var(--cyber-pink);">${favorites.length}</strong>
                                        <br><small>Events Starred</small>
                                    </div>
                                    <div style="background: rgba(0, 255, 255, 0.1); padding: 10px; border-radius: 6px; text-align: center;">
                                        <strong style="color: var(--cyber-blue);">${Object.keys(eventTracking).length}</strong>
                                        <br><small>Events Tracked</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="text-align: center; margin-top: 20px; padding-top: 15px; border-top: 1px solid rgba(100, 150, 200, 0.3);">
                        <button onclick="sendNewsletterEmail()" class="cyber-button" style="margin-right: 10px; background: linear-gradient(45deg, var(--cyber-green), var(--cyber-blue));">
                            📧 Send to My Email
                        </button>
                        <button onclick="this.parentElement.parentElement.parentElement.remove()" class="cyber-button">
                            Close Preview
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        // Send newsletter email
        async function sendNewsletterEmail() {
            if (!currentUser || !currentUser.email) {
                showNotification('❌ Please log in to send newsletter to your email', 'error');
                return;
            }

            try {
                const searchHistory = getSearchHistory();
                const favorites = await getFavorites();
                
                const response = await fetch('/api/send-newsletter', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        email: currentUser.email,
                        searchHistory: searchHistory.slice(0, 10),
                        favorites: favorites.slice(0, 10),
                        userName: currentUser.firstName || currentUser.username
                    })
                });

                if (response.ok) {
                    showNotification('📧 Newsletter sent to your email successfully!', 'success');
                } else {
                    let errorMessage = 'Unknown error';
                    try {
                        const error = await response.json();
                        errorMessage = error.error || error.message || 'Failed to send newsletter';
                    } catch (parseError) {
                        errorMessage = `Server error (${response.status})`;
                    }
                    showNotification(`❌ Failed to send newsletter: ${errorMessage}`, 'error');
                }
            } catch (error) {
                console.error('Newsletter send error:', error);
                showNotification('❌ Failed to send newsletter. Please try again.', 'error');
            }
        }

        async function loadSearchHistory() {
            const localSearches = getSearchHistory();
            const historyContainer = document.getElementById('searchHistory');
            
            // Try to load database searches if user is authenticated
            let databaseSearches = [];
            try {
                const response = await fetch('/api/user/searches?limit=10', {
                    credentials: 'include'
                });
                if (response.ok) {
                    const data = await response.json();
                    databaseSearches = data.searches;
                }
            } catch (error) {
                console.log('Could not load database searches (user may not be logged in)');
            }

            // Combine and deduplicate searches
            const allSearches = [...databaseSearches, ...localSearches];
            const uniqueSearches = allSearches.filter((search, index, self) => 
                index === self.findIndex(s => s.query === search.query && 
                    Math.abs(new Date(s.timestamp || s.createdAt) - new Date(search.timestamp || search.createdAt)) < 60000)
            ).slice(0, 20);
            
            if (uniqueSearches.length === 0) {
                historyContainer.innerHTML = `
                    <div style="color: #666; text-align: center; padding: 20px;">
                        <p>No searches yet</p>
                        ${databaseSearches.length === 0 ? '<p style="font-size: 0.8rem; margin-top: 10px;">🔐 Login to save searches permanently</p>' : ''}
                    </div>`;
                return;
            }
            
            const historyHTML = uniqueSearches.map(search => {
                const isFromDatabase = search._id; // Database searches have _id
                const date = new Date(search.timestamp || search.createdAt);
                const eventsCount = search.eventsFound || search.resultCounts?.events || 0;
                const newsCount = search.newsFound || search.resultCounts?.news || 0;
                const totalCount = search.totalResults || search.resultCounts?.total || (eventsCount + newsCount);
                
                return `
                    <div class="history-item">
                        <div class="history-content" onclick="repeatSearch('${search.query}')">
                            <div class="history-query">${search.query}${search.location ? ` in ${search.location}` : ''}</div>
                            <div class="history-date">${date.toLocaleDateString()} ${date.toLocaleTimeString()}</div>
                            <div class="history-results">
                                📅 ${eventsCount} events • 📰 ${newsCount} news
                                ${search.resultCounts?.github ? ` • 💻 ${search.resultCounts.github} repos` : ''}
                                ${search.resultCounts?.reddit ? ` • � ${search.resultCounts.reddit} posts` : ''}
                            </div>
                        </div>
                        <div style="display: flex; gap: 5px; align-items: center;">
                            ${isFromDatabase ? `
                                <div class="preview-btn" onclick="previewSearch('${search._id}')" title="Preview search results">
                                    👁️
                                </div>
                                <div class="delete-btn" onclick="deleteDBSearch('${search._id}')" title="Delete this search">
                                    🗑️
                                </div>
                            ` : `
                                <div class="delete-btn" onclick="deleteHistoryItem(${search.id})" title="Delete this search">
                                    🗑️
                                </div>
                            `}
                        </div>
                    </div>
                `;
            }).join('');
            
            historyContainer.innerHTML = historyHTML;
        }

        function updateSearchStats() {
            const searches = getSearchHistory();
            const totalSearches = searches.length;
            const totalEvents = searches.reduce((sum, search) => sum + (search.eventsFound || 0), 0);
            const totalNews = searches.reduce((sum, search) => sum + (search.newsFound || 0), 0);
            
            document.getElementById('totalSearches').textContent = totalSearches;
            document.getElementById('totalEvents').textContent = totalEvents;
            document.getElementById('totalNews').textContent = totalNews;
        }

        function repeatSearch(query) {
            const queryInput = document.getElementById('queryInput') || document.getElementById('universalSearchQuery');
            if (queryInput) {
                queryInput.value = query;
                closeSidebar();
                performComprehensiveSearch(); // Fixed: use the correct search function
            }
        }

        function deleteHistoryItem(searchId) {
            const searches = getSearchHistory();
            const updatedSearches = searches.filter(search => search.id !== searchId);
            localStorage.setItem('prospectorSearchHistory', JSON.stringify(updatedSearches));
            loadSearchHistory();
            updateStats();
        }

        function clearSearchHistory() {
            if (confirm('Are you sure you want to clear all search history?')) {
                localStorage.removeItem('prospectorSearchHistory');
                loadSearchHistory();
                updateStats();
            }
        }

        // Open Calendar Mode from sidebar
        function openCalendarMode() {
            // Show the calendar page within the app
            showCalendarPage();
            
            // Close the sidebar
            closeSidebar();
            
            // Scroll to top
            window.scrollTo(0, 0);
        }

        function updateStats() {
            const searchHistory = JSON.parse(localStorage.getItem('prospectorSearchHistory') || '[]');
            
            // Update total searches
            document.getElementById('totalSearches').textContent = searchHistory.length;
            
            // Calculate total events and news found
            let totalEvents = 0;
            let totalNews = 0;
            
            searchHistory.forEach(search => {
                if (search.results) {
                    if (search.results.events) {
                        totalEvents += search.results.events.length;
                    }
                    if (search.results.news) {
                        totalNews += search.results.news.length;
                    }
                    if (search.results.github) {
                        // Count GitHub results as tech news
                        totalNews += search.results.github.length;
                    }
                    if (search.results.reddit) {
                        // Count Reddit results as news/discussions
                        totalNews += search.results.reddit.length;
                    }
                }
            });
            
            document.getElementById('totalEvents').textContent = totalEvents;
            document.getElementById('totalNews').textContent = totalNews;
        }

        // ==================== EVENT INTERACTION FUNCTIONS ====================

        // Function to open event source URL
        function openEventSource(url, title) {
            if (url && url !== '#') {
                // Track the event click behavior
                if (currentUser) {
                    trackUserBehavior('event_click', 'event', title, { url: url });
                }
                // Open the source URL in a new tab
                window.open(url, '_blank');
            } else {
                console.log('No source URL available for this event');
            }
        }

        // Function to toggle event wishlist status
        async function toggleEventWish(event, eventData) {
            event.stopPropagation(); // Prevent triggering the parent click event
            
            if (!currentUser) {
                alert('Please log in to save events to your wishlist');
                return;
            }

            try {
                const button = event.target;
                const isCurrentlyStarred = button.classList.contains('starred');
                
                if (isCurrentlyStarred) {
                    // Remove from wishlist (we'd need the wish ID for this - for now just show message)
                    console.log('Remove from wishlist functionality - to be implemented');
                    button.classList.remove('starred');
                    button.innerHTML = '⭐';
                    showNotification('Event removed from wishlist', 'success');
                } else {
                    // Add to wishlist
                    const wishData = {
                        eventData: {
                            eventTitle: eventData.title,
                            eventDescription: eventData.description,
                            eventDate: eventData.date,
                            eventTime: eventData.time,
                            eventLocation: eventData.location,
                            eventUrl: eventData.url,
                            source: eventData.source,
                            category: eventData.category,
                            status: 'active',
                            priority: 'medium'
                        }
                    };

                    const response = await fetch('/api/user/wishes', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(wishData),
                        credentials: 'include'
                    });

                    if (response.ok) {
                        const result = await response.json();
                        console.log('✅ Event saved to wishlist:', result);
                        
                        // Update button appearance
                        button.classList.add('starred');
                        button.innerHTML = '⭐';
                        button.style.backgroundColor = 'var(--cyber-blue)';
                        button.style.color = 'black';
                        
                        // Track the wishlist action
                        trackUserBehavior('event_wishlist', 'event', eventData.title, { 
                            action: 'add',
                            wishId: result.wish._id 
                        });
                        
                        showNotification('Event saved to wishlist!', 'success');
                    } else {
                        console.error('❌ Failed to save event to wishlist');
                        showNotification('Failed to save event', 'error');
                    }
                }
            } catch (error) {
                console.error('❌ Error toggling event wish:', error);
                showNotification('Error saving event', 'error');
            }
        }

        // Function to show notifications
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 20px;
                border-radius: 8px;
                color: white;
                font-weight: bold;
                z-index: 10000;
                transition: all 0.3s ease;
                ${type === 'success' ? 'background: var(--cyber-green);' : ''}
                ${type === 'error' ? 'background: var(--cyber-pink);' : ''}
                ${type === 'info' ? 'background: var(--cyber-blue);' : ''}
            `;
            notification.textContent = message;
            
            // Add to page
            document.body.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        // Function to track user behavior
        async function trackUserBehavior(action, entityType, entityId, context = {}) {
            if (!currentUser) return;
            
            try {
                await fetch('/api/user/behavior', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        action: action,
                        entityType: entityType,
                        entityId: entityId,
                        context: context
                    }),
                    credentials: 'include'
                });
            } catch (error) {
                console.log('Failed to track user behavior:', error);
            }
        }

        // ==================== AUTHENTICATION FUNCTIONS ====================

        let currentUser = null;

        // Check authentication status on page load
        async function checkAuthStatus() {
            console.log('🔍 Checking authentication status...');
            try {
                const response = await fetch('/api/auth/me', {
                    credentials: 'include'
                });
                
                console.log('📡 Auth check response status:', response.status);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('✅ Authentication successful:', data);
                    currentUser = data.user;
                    updateUIForAuthenticatedUser();
                    // Sync any locally-stored favorites to the server now that user is authenticated
                    try { await syncLocalFavoritesToServer(); } catch(e) { console.warn('Favorites sync failed:', e); }
                } else {
                    console.log('❌ Authentication failed, status:', response.status);
                    currentUser = null;
                    updateUIForGuestUser();
                }
            } catch (error) {
                console.log('🚨 Auth check failed with error:', error);
                currentUser = null;
                updateUIForGuestUser();
            }
        }

        // Update UI for authenticated user
        function updateUIForAuthenticatedUser() {
            document.getElementById('guestControls').style.display = 'none';
            document.getElementById('userControls').style.display = 'flex';
            document.getElementById('userWelcome').textContent = `Welcome, ${currentUser.firstName || currentUser.username}!`;
            
            // Close auth modal if open
            closeAuthModal();
            
            // Add debug info
            console.log('✅ User authenticated:', {
                id: currentUser._id,
                username: currentUser.username,
                email: currentUser.email
            });
            // Show calendar quick-action in sidebar for authenticated users
            const openCalBtn = document.getElementById('openCalendarBtn');
            if (openCalBtn) openCalBtn.style.display = 'block';
            // Start loading Google APIs in the background so calendar operations are ready
            try {
                if (typeof initializeGoogleApis === 'function') {
                    initializeGoogleApis().catch(err => console.warn('Google API init (background) failed:', err));
                }
            } catch (e) {
                console.warn('Failed to kick off Google API initialization:', e);
            }
        }

        // Update UI for guest user
        function updateUIForGuestUser() {
            document.getElementById('guestControls').style.display = 'flex';
            document.getElementById('userControls').style.display = 'none';
            // Hide calendar quick-action for guests
            const openCalBtn = document.getElementById('openCalendarBtn');
            if (openCalBtn) openCalBtn.style.display = 'none';
        }

        // Show login form
        function showLoginForm() {
            document.getElementById('authModal').style.display = 'flex';
            document.getElementById('loginForm').style.display = 'block';
            document.getElementById('registerForm').style.display = 'none';
            document.getElementById('profileForm').style.display = 'none';
            document.getElementById('changePasswordForm').style.display = 'none';
        }

        // Show register form
        function showRegisterForm() {
            document.getElementById('authModal').style.display = 'flex';
            document.getElementById('loginForm').style.display = 'none';
            document.getElementById('registerForm').style.display = 'block';
            document.getElementById('profileForm').style.display = 'none';
            document.getElementById('changePasswordForm').style.display = 'none';
        }

        // Show profile form
        function showProfileForm() {
            if (!currentUser) {
                showLoginForm();
                return;
            }
            
            document.getElementById('authModal').style.display = 'flex';
            document.getElementById('loginForm').style.display = 'none';
            document.getElementById('registerForm').style.display = 'none';
            document.getElementById('profileForm').style.display = 'block';
            document.getElementById('changePasswordForm').style.display = 'none';
            
            // Populate form with current user data
            document.getElementById('profileFirstName').value = currentUser.firstName || '';
            document.getElementById('profileLastName').value = currentUser.lastName || '';
            document.getElementById('profileDefaultLocation').value = currentUser.preferences?.defaultLocation || '';
            document.getElementById('profileEmailNotifications').checked = currentUser.preferences?.emailNotifications !== false;
        }

        // Show change password form
        function showChangePassword() {
            document.getElementById('profileForm').style.display = 'none';
            document.getElementById('changePasswordForm').style.display = 'block';
        }

        // Switch between login and register
        function switchToLogin() {
            showLoginForm();
        }

        function switchToRegister() {
            showRegisterForm();
        }

        // Close modal
        function closeAuthModal() {
            document.getElementById('authModal').style.display = 'none';
            // Clear all forms
            document.querySelectorAll('#authModal form').forEach(form => form.reset());
        }

        // Login function
        async function login(event) {
            event.preventDefault();
            
            const username = document.getElementById('loginUsername').value;
            const password = document.getElementById('loginPassword').value;
            
            try {
                const response = await fetch('/api/auth/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    credentials: 'include',
                    body: JSON.stringify({ username, password })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    currentUser = data.user;
                    updateUIForAuthenticatedUser();
                    closeAuthModal();
                    showNotification('🎉 Login successful! Welcome back, agent.', 'success');
                } else {
                    showNotification(`❌ ${data.error}`, 'error');
                }
            } catch (error) {
                showNotification('❌ Login failed. Check your connection.', 'error');
            }
        }

        // Register function
        async function register(event) {
            event.preventDefault();
            
            const username = document.getElementById('regUsername').value;
            const email = document.getElementById('regEmail').value;
            const password = document.getElementById('regPassword').value;
            const firstName = document.getElementById('regFirstName').value;
            const lastName = document.getElementById('regLastName').value;
            
            try {
                const response = await fetch('/api/auth/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    credentials: 'include',
                    body: JSON.stringify({ username, email, password, firstName, lastName })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    currentUser = data.user;
                    updateUIForAuthenticatedUser();
                    closeAuthModal();
                    showNotification('🎉 Registration successful! Welcome to the network, agent.', 'success');
                } else {
                    showNotification(`❌ ${data.error}`, 'error');
                }
            } catch (error) {
                showNotification('❌ Registration failed. Check your connection.', 'error');
            }
        }

        // Update profile function
        async function updateProfile(event) {
            event.preventDefault();
            
            const firstName = document.getElementById('profileFirstName').value;
            const lastName = document.getElementById('profileLastName').value;
            const defaultLocation = document.getElementById('profileDefaultLocation').value;
            const emailNotifications = document.getElementById('profileEmailNotifications').checked;
            
            try {
                const response = await fetch('/api/auth/profile', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        firstName,
                        lastName,
                        preferences: {
                            defaultLocation,
                            emailNotifications
                        }
                    })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    currentUser = data.user;
                    updateUIForAuthenticatedUser();
                    closeAuthModal();
                    showNotification('✅ Profile updated successfully!', 'success');
                } else {
                    showNotification(`❌ ${data.error}`, 'error');
                }
            } catch (error) {
                showNotification('❌ Profile update failed. Check your connection.', 'error');
            }
        }

        // Change password function
        async function changePassword(event) {
            event.preventDefault();
            
            const currentPassword = document.getElementById('currentPassword').value;
            const newPassword = document.getElementById('newPassword').value;
            const confirmPassword = document.getElementById('confirmPassword').value;
            
            if (newPassword !== confirmPassword) {
                showNotification('❌ New passwords do not match!', 'error');
                return;
            }
            
            try {
                const response = await fetch('/api/auth/password', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    credentials: 'include',
                    body: JSON.stringify({ currentPassword, newPassword })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    closeAuthModal();
                    showNotification('🔒 Password changed successfully!', 'success');
                } else {
                    showNotification(`❌ ${data.error}`, 'error');
                }
            } catch (error) {
                showNotification('❌ Password change failed. Check your connection.', 'error');
            }
        }

        // Logout function
        async function logout() {
            try {
                const response = await fetch('/api/auth/logout', {
                    method: 'POST',
                    credentials: 'include'
                });
                
                if (response.ok) {
                    currentUser = null;
                    updateUIForGuestUser();
                    showNotification('👋 Logged out successfully. Stay safe out there, agent.', 'success');
                } else {
                    showNotification('❌ Logout failed', 'error');
                }
            } catch (error) {
                showNotification('❌ Logout failed. Check your connection.', 'error');
            }
        }

        // Show notification function
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 20px;
                border-radius: 8px;
                color: white;
                font-family: 'Orbitron', monospace;
                font-weight: bold;
                z-index: 10000;
                max-width: 400px;
                word-wrap: break-word;
                background: ${type === 'success' ? 'linear-gradient(45deg, var(--cyber-green), var(--cyber-blue))' : 
                           type === 'error' ? 'linear-gradient(45deg, var(--cyber-pink), var(--cyber-orange))' :
                           'linear-gradient(45deg, var(--cyber-blue), var(--cyber-purple))'};
                border: 2px solid ${type === 'success' ? 'var(--cyber-green)' : 
                                  type === 'error' ? 'var(--cyber-pink)' : 'var(--cyber-blue)'};
                animation: slideInRight 0.3s ease-out;
            `;
            
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.3s ease-in forwards';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 4000);
        }

        // Add notification animations to CSS
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideInRight {
                from { opacity: 0; transform: translateX(100%); }
                to { opacity: 1; transform: translateX(0); }
            }
            @keyframes slideOutRight {
                from { opacity: 1; transform: translateX(0); }
                to { opacity: 0; transform: translateX(100%); }
            }
        `;
        document.head.appendChild(style);

        // ==================== END AUTHENTICATION FUNCTIONS ====================

        // Handle Enter key for universal search input
        document.getElementById('universalSearchQuery').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                performComprehensiveSearch();
            }
        });

        // Handle Enter key for social search input
        const socialSearchInput = document.getElementById('socialSearchQuery');
        if (socialSearchInput) {
            socialSearchInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    generalSearch();
                }
            });
        }

        // ==================== SEARCH PREVIEW FUNCTIONS ====================

        // Preview search results
        async function previewSearch(searchId) {
            try {
                const response = await fetch(`/api/search/${searchId}`, {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    throw new Error('Failed to load search preview');
                }
                
                const searchData = await response.json();
                showPreviewModal(searchData);
                
            } catch (error) {
                console.error('Preview error:', error);
                alert('Failed to load search preview: ' + error.message);
            }
        }

        // Show preview modal with search data
        function showPreviewModal(searchData) {
            const modal = document.getElementById('previewModal');
            const detailsDiv = document.getElementById('previewDetails');
            const resultsDiv = document.getElementById('previewResults');
            
            // Format search details
            const date = new Date(searchData.createdAt);
            const detailsHTML = `
                <div style="background: rgba(0, 255, 255, 0.1); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                    <h3 style="color: var(--cyber-green); margin: 0 0 10px 0;">"${searchData.query}"</h3>
                    ${searchData.location ? `<p style="color: var(--cyber-orange); margin: 5px 0;"><strong>📍 Location:</strong> ${searchData.location}</p>` : ''}
                    <p style="color: var(--cyber-blue); margin: 5px 0;"><strong>🕒 Search Date:</strong> ${date.toLocaleDateString()} ${date.toLocaleTimeString()}</p>
                    <p style="color: var(--cyber-pink); margin: 5px 0;"><strong>🎯 Mode:</strong> ${searchData.searchMode || 'auto'}</p>
                    <div style="display: flex; gap: 15px; margin-top: 10px; flex-wrap: wrap;">
                        ${searchData.resultCounts.events > 0 ? `<span style="color: var(--cyber-blue);">🎪 ${searchData.resultCounts.events} Events</span>` : ''}
                        ${searchData.resultCounts.news > 0 ? `<span style="color: var(--cyber-pink);">📰 ${searchData.resultCounts.news} News</span>` : ''}
                        ${searchData.resultCounts.github > 0 ? `<span style="color: var(--cyber-green);">💻 ${searchData.resultCounts.github} GitHub</span>` : ''}
                        ${searchData.resultCounts.reddit > 0 ? `<span style="color: var(--cyber-orange);">💬 ${searchData.resultCounts.reddit} Reddit</span>` : ''}
                    </div>
                </div>
            `;
            
            // Format results
            const resultsHTML = searchData.results.map(result => {
                const typeColors = {
                    'event': 'var(--cyber-blue)',
                    'news': 'var(--cyber-pink)',
                    'github': 'var(--cyber-green)',
                    'reddit': 'var(--cyber-orange)'
                };

                const typeIcons = {
                    'event': '🎪',
                    'news': '📰',
                    'github': '💻',
                    'reddit': '💬'
                };

                // Create a stable id for this preview item
                const resultId = result.url || result.id || result.title || ('preview-' + Math.floor(Math.random() * 1000000));
                const isStarred = isItemStarred(resultId);
                const evMeta = {
                    title: result.title || 'Preview Item',
                    description: result.description || '',
                    link: result.url || '',
                    eventDate: result.metadata?.date || undefined,
                    eventLocation: result.metadata?.venue || undefined,
                    source: result.source || 'prospector'
                };

                return `
                    <div class="preview-result-item" style="border-left-color: ${typeColors[result.type] || 'var(--cyber-green)'}; position: relative;">
                        <div style="position: absolute; top: 10px; right: 12px;">
                            <button class="star-btn ${isStarred ? 'starred' : ''}" onclick="toggleStar('${escapeForJS(resultId)}', '${encodeURIComponent(JSON.stringify(evMeta))}')" title="⭐ Star and add to Google Calendar" style="padding:6px 8px; border-radius:6px; background: rgba(0,255,255,0.2) !important; border:1px solid var(--cyber-blue) !important; color: var(--cyber-blue) !important; font-weight: bold !important;">
                                ${isStarred ? '★ Starred' : '☆ Star'}
                            </button>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                            <div style="flex: 1;">
                                <h4 style="color: var(--cyber-blue); margin: 0 0 5px 0; font-size: 1rem;">${result.title}</h4>
                                <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 8px;">
                                    <span style="color: ${typeColors[result.type] || 'var(--cyber-green)'}; font-size: 0.8rem; font-weight: bold; background: rgba(0,0,0,0.5); padding: 2px 6px; border-radius: 10px;">
                                        ${typeIcons[result.type] || '🔍'} ${result.source}
                                    </span>
                                    ${result.metadata?.date ? `<span style="color: var(--cyber-green); font-size: 0.8rem;">📅 ${new Date(result.metadata.date).toLocaleDateString()}</span>` : ''}
                                    ${result.metadata?.venue ? `<span style="color: var(--cyber-orange); font-size: 0.8rem;">📍 ${result.metadata.venue}</span>` : ''}
                                    ${result.metadata?.stars ? `<span style="color: var(--cyber-green); font-size: 0.8rem;">⭐ ${result.metadata.stars}</span>` : ''}
                                    ${result.metadata?.score ? `<span style="color: var(--cyber-orange); font-size: 0.8rem;">👍 ${result.metadata.score}</span>` : ''}
                                </div>
                            </div>
                        </div>
                        ${result.url ? `<a href="${result.url}" target="_blank" style="color: var(--cyber-green); text-decoration: none; font-size: 0.9rem; display: block; margin: 8px 0; word-break: break-all;">${result.url}</a>` : ''}
                        <div style="color: #ccc; font-size: 0.9rem; line-height: 1.4;">${result.description || 'No description available'}</div>
                    </div>
                `;
            }).join('');
            
            detailsDiv.innerHTML = detailsHTML;
            resultsDiv.innerHTML = resultsHTML || '<p style="text-align: center; color: #666;">No results available</p>';
            
            modal.classList.add('show');
        }

        // Close preview modal
        function closePreviewModal() {
            const modal = document.getElementById('previewModal');
            modal.classList.remove('show');
        }

        // Delete database search
        async function deleteDBSearch(searchId) {
            if (!confirm('Are you sure you want to delete this search?')) {
                return;
            }
            
            try {
                const response = await fetch(`/api/search/${searchId}`, {
                    method: 'DELETE',
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    throw new Error('Failed to delete search');
                }
                
                // Reload search history
                loadSearchHistory();
                
            } catch (error) {
                console.error('Delete error:', error);
                alert('Failed to delete search: ' + error.message);
            }
        }

        // Click outside to close preview modal
        document.getElementById('previewModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closePreviewModal();
            }
        });

        // ==================== END SEARCH PREVIEW FUNCTIONS ====================

        // Initialize
        createParticles();
        loadSearchHistory();
        updateSearchStats();
        
        // Initialize particles and other UI elements when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('The Prospector loaded - Google Calendar API will initialize when accessed');
            
            // Check authentication status first before initializing the UI
            checkAuthStatus().then(() => {
                console.log('Auth check completed, initializing UI');
            }).catch((error) => {
                console.log('Auth check failed, continuing with guest UI:', error);
            }).finally(() => {
                // Always show the search page after auth check
                showSearchPage();
            });
            
            // Check for saved Google auth state
            const hasAuth = loadGoogleAuthState();
            if (hasAuth) {
                console.log('Google Calendar session restored from localStorage');
                // Initialize Google APIs in background if auth is available
                setTimeout(() => {
                    if (typeof initializeGoogleApis === 'function') {
                        initializeGoogleApis().then(() => {
                            if (isGoogleSignedIn) {
                                updateCalendarUI();
                            }
                        }).catch(err => console.warn('Background Google API init failed:', err));
                    }
                }, 1000);
            }
        });
        
        // Add some sample history if none exists
        const existingHistory = getSearchHistory();
        if (existingHistory.length === 0) {
            // Add sample searches to demonstrate the feature with new format
            const sampleSearches = [
                { query: "music festivals", eventsFound: 12, newsFound: 8 },
                { query: "tech meetups", eventsFound: 7, newsFound: 5 },
                { query: "food events", eventsFound: 15, newsFound: 3 }
            ];
            
            sampleSearches.forEach((search, index) => {
                const timestamp = new Date();
                timestamp.setHours(timestamp.getHours() - (index + 1));
                
                const newSearch = {
                    id: Date.now() + index,
                    query: search.query,
                    location: '',
                    timestamp: timestamp.toISOString(),
                    eventsFound: search.eventsFound,
                    newsFound: search.newsFound,
                    githubFound: 0,
                    redditFound: 0,
                    totalResults: search.eventsFound + search.newsFound
                };
                
                const searches = getSearchHistory();
                searches.unshift(newSearch);
                localStorage.setItem('prospectorSearchHistory', JSON.stringify(searches));
            });
            
            loadSearchHistory();
            updateSearchStats();
        }

        // Page Navigation Functions
        function showSearchPage() {
            document.getElementById('searchPage').style.display = 'block';
            document.getElementById('calendarPage').style.display = 'none';
            
            // Update button states
            document.getElementById('searchPageBtn').style.background = 'linear-gradient(45deg, var(--cyber-blue), var(--cyber-green))';
            document.getElementById('calendarPageBtn').style.background = 'linear-gradient(45deg, #333, #555)';
        }

        async function showCalendarPage() {
            document.getElementById('searchPage').style.display = 'none';
            document.getElementById('calendarPage').style.display = 'block';
            
            // Update button states
            document.getElementById('searchPageBtn').style.background = 'linear-gradient(45deg, #333, #555)';
            document.getElementById('calendarPageBtn').style.background = 'linear-gradient(45deg, var(--cyber-blue), var(--cyber-green))';
            
            // Load saved events from search history
            await loadSavedEvents();
            
            // Load recent search history for calendar
            loadSearchHistoryForCalendar();
        }

        // Load saved events from search history with source links
        async function loadSavedEvents() {
            const savedEventsContainer = document.getElementById('savedEventsContainer');
            if (!savedEventsContainer) return;
            
            // Show loading state
            savedEventsContainer.innerHTML = '<p style="text-align: center; color: #666;">Loading saved events...</p>';
            
            const favorites = await getFavorites();
            
            if (favorites.length === 0) {
                savedEventsContainer.innerHTML = '<p style="text-align: center; color: #666;">No saved events from search history yet...</p>';
                return;
            }

            let eventsHTML = '';
            favorites.forEach(item => {
                // Check if the item has event-like properties (time, location, etc.)
                if (item.title && (item.time || item.location || item.date)) {
                    eventsHTML += `
                        <div style="border: 1px solid var(--cyber-pink); border-radius: 8px; padding: 15px; margin-bottom: 10px; background: rgba(255, 0, 128, 0.05);">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                                <h4 style="color: var(--cyber-pink); margin: 0;">${escapeHtml(item.title)}</h4>
                                <button onclick="addSavedEventToCalendar('${item.id}')" class="cyber-button" style="padding: 5px 10px; font-size: 0.8rem;">
                                    ➕ Add to Calendar
                                </button>
                            </div>
                            ${item.time ? `<p style="color: var(--cyber-green); margin: 5px 0;"><strong>Time:</strong> ${escapeHtml(item.time)}</p>` : ''}
                            ${item.date ? `<p style="color: var(--cyber-green); margin: 5px 0;"><strong>Date:</strong> ${escapeHtml(item.date)}</p>` : ''}
                            ${item.location ? `<p style="color: var(--cyber-blue); margin: 5px 0;"><strong>Location:</strong> ${escapeHtml(item.location)}</p>` : ''}
                            ${item.description ? `<p style="color: #ccc; margin: 5px 0; font-size: 0.9rem;">${escapeHtml(item.description.substring(0, 200))}${item.description.length > 200 ? '...' : ''}</p>` : ''}
                            ${item.link ? `
                                <div style="margin: 10px 0;">
                                    <a href="${item.link}" target="_blank" style="color: var(--cyber-green); text-decoration: none; font-size: 0.9rem; display: inline-flex; align-items: center; gap: 8px; background: rgba(0, 255, 0, 0.1); padding: 8px 12px; border-radius: 8px; border: 1px solid var(--cyber-green); transition: all 0.3s ease;">
                                        🔗 <span style="font-weight: bold;">View Source</span>
                                        <span style="font-size: 0.8rem; opacity: 0.8;">(${new URL(item.link).hostname})</span>
                                    </a>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }
            });

            if (eventsHTML === '') {
                savedEventsContainer.innerHTML = '<p style="text-align: center; color: #666;">No event-like items found in favorites. Star some events from search results!</p>';
            } else {
                savedEventsContainer.innerHTML = eventsHTML;
            }
        }

        // Add saved event to Google Calendar
        async function addSavedEventToCalendar(itemId) {
            const favorites = await getFavorites();
            const item = favorites.find(fav => fav.id === itemId);
            
            if (!item) {
                showNotification('❌ Event not found in favorites', 'error');
                return;
            }

            if (!isGoogleSignedIn) {
                showNotification('❌ Please sign in to Google Calendar first', 'error');
                return;
            }

            // Pre-fill the event form with saved data
            document.getElementById('eventTitle').value = item.title || '';
            document.getElementById('eventLocation').value = item.location || '';
            
            // Try to parse date/time if available
            if (item.date || item.time) {
                const dateStr = item.date || '';
                const timeStr = item.time || '';
                // You might need to improve this parsing based on your data format
                const combinedDateTime = `${dateStr} ${timeStr}`.trim();
                if (combinedDateTime) {
                    // Try to create a datetime-local format (YYYY-MM-DDTHH:MM)
                    const parsedDate = new Date(combinedDateTime);
                    if (!isNaN(parsedDate.getTime())) {
                        const localDateTime = parsedDate.toISOString().slice(0, 16);
                        document.getElementById('eventDateTime').value = localDateTime;
                    }
                }
            }

            // Show notification
            showNotification('📅 Event details pre-filled! Complete the form and click "Add Event"', 'success');
            
            // Scroll to event form
            document.getElementById('eventForm').scrollIntoView({ behavior: 'smooth' });
        }

        // Helper function to get human-readable time ago
        function getTimeAgo(timestamp) {
            const now = Date.now();
            const diff = now - timestamp;
            
            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            
            if (days > 0) {
                return days === 1 ? '1 day ago' : `${days} days ago`;
            } else if (hours > 0) {
                return hours === 1 ? '1 hour ago' : `${hours} hours ago`;
            } else if (minutes > 0) {
                return minutes === 1 ? '1 minute ago' : `${minutes} minutes ago`;
            } else {
                return 'Just now';
            }
        }

        // Load search history for calendar page
        async function loadSearchHistoryForCalendar() {
            const historyContainer = document.getElementById('calendarHistoryContainer');
            if (!historyContainer) return;

            try {
                const localSearches = getSearchHistory();
                
                // Try to load database searches if user is authenticated
                let databaseSearches = [];
                try {
                    const response = await fetch('/api/user/searches?limit=5', {
                        credentials: 'include'
                    });
                    if (response.ok) {
                        const data = await response.json();
                        databaseSearches = data.searches || [];
                    }
                } catch (error) {
                    console.log('Could not load database searches (user may not be logged in)');
                }

                // Combine and deduplicate searches
                const allSearches = [...databaseSearches, ...localSearches];
                const uniqueSearches = [];
                const seenQueries = new Set();
                
                for (const search of allSearches) {
                    if (!seenQueries.has(search.query) && uniqueSearches.length < 10) {
                        seenQueries.add(search.query);
                        uniqueSearches.push(search);
                    }
                }

                if (uniqueSearches.length === 0) {
                    historyContainer.innerHTML = '<p style="text-align: center; color: #666;">No search history yet. Perform some searches to see them here!</p>';
                    return;
                }

                let historyHTML = '';
                uniqueSearches.forEach((search, index) => {
                    const timeAgo = getTimeAgo(search.timestamp || Date.now());
                    historyHTML += `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; margin-bottom: 8px; background: rgba(255, 107, 0, 0.1); border: 1px solid rgba(255, 107, 0, 0.3); border-radius: 6px;">
                            <div style="flex: 1;">
                                <div style="color: var(--cyber-orange); font-weight: bold; margin-bottom: 3px;">
                                    ${escapeHtml(search.query)}
                                </div>
                                <div style="color: #999; font-size: 0.8rem;">
                                    ${timeAgo} • ${search.results || 0} results
                                </div>
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <button onclick="searchFromHistory('${escapeHtml(search.query)}')" class="cyber-button" style="padding: 5px 10px; font-size: 0.8rem;">
                                    🔍 Search Again
                                </button>
                                <button onclick="createEventFromSearch('${escapeHtml(search.query)}')" class="cyber-button" style="padding: 5px 10px; font-size: 0.8rem; background: linear-gradient(45deg, var(--cyber-pink), var(--cyber-purple));">
                                    📅 Create Event
                                </button>
                            </div>
                        </div>
                    `;
                });

                historyContainer.innerHTML = historyHTML;

            } catch (error) {
                console.error('Error loading search history for calendar:', error);
                historyContainer.innerHTML = '<p style="text-align: center; color: #ff6b6b;">Error loading search history</p>';
            }
        }

        // Show all search history in calendar context
        function showAllHistoryForCalendar() {
            // Create modal to show all search history
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 800px; max-height: 80vh; overflow-y: auto;">
                    <span class="close" onclick="this.parentElement.parentElement.remove()">&times;</span>
                    <h2 style="color: var(--cyber-orange); text-align: center; margin-bottom: 20px;">📚 All Search History</h2>
                    <div id="allHistoryContainer" style="max-height: 60vh; overflow-y: auto;">
                        <p style="text-align: center; color: #666;">Loading all search history...</p>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Load all search history
            loadAllSearchHistoryForModal();
        }

        // Load all search history for modal
        async function loadAllSearchHistoryForModal() {
            const container = document.getElementById('allHistoryContainer');
            if (!container) return;

            try {
                const localSearches = getSearchHistory();
                
                // Try to load all database searches if user is authenticated
                let databaseSearches = [];
                try {
                    const response = await fetch('/api/user/searches', {
                        credentials: 'include'
                    });
                    if (response.ok) {
                        const data = await response.json();
                        databaseSearches = data.searches || [];
                    }
                } catch (error) {
                    console.log('Could not load database searches (user may not be logged in)');
                }

                // Combine and sort by timestamp
                const allSearches = [...databaseSearches, ...localSearches];
                allSearches.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));

                if (allSearches.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666;">No search history found.</p>';
                    return;
                }

                let historyHTML = '';
                allSearches.forEach((search, index) => {
                    const timeAgo = getTimeAgo(search.timestamp || Date.now());
                    historyHTML += `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; margin-bottom: 10px; background: rgba(255, 107, 0, 0.08); border: 1px solid rgba(255, 107, 0, 0.2); border-radius: 8px;">
                            <div style="flex: 1;">
                                <div style="color: var(--cyber-orange); font-weight: bold; margin-bottom: 5px;">
                                    ${escapeHtml(search.query)}
                                </div>
                                <div style="color: #999; font-size: 0.8rem;">
                                    ${timeAgo} • ${search.results || 0} results
                                    ${search.source ? ` • Source: ${search.source}` : ''}
                                </div>
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <button onclick="searchFromHistory('${escapeHtml(search.query)}'); this.closest('.modal').remove();" class="cyber-button" style="padding: 5px 10px; font-size: 0.8rem;">
                                    🔍 Search
                                </button>
                                <button onclick="createEventFromSearch('${escapeHtml(search.query)}'); this.closest('.modal').remove();" class="cyber-button" style="padding: 5px 10px; font-size: 0.8rem; background: linear-gradient(45deg, var(--cyber-pink), var(--cyber-purple));">
                                    📅 Event
                                </button>
                            </div>
                        </div>
                    `;
                });

                container.innerHTML = historyHTML;

            } catch (error) {
                console.error('Error loading all search history:', error);
                container.innerHTML = '<p style="text-align: center; color: #ff6b6b;">Error loading search history</p>';
            }
        }

        // Search again from history
        function searchFromHistory(query) {
            // Switch to search page and perform the search
            showSearchPage();
            document.getElementById('searchInput').value = query;
            searchEvents();
        }

        // Create event from search query
        function createEventFromSearch(query) {
            if (!isGoogleSignedIn) {
                showNotification('❌ Please sign in to Google Calendar first', 'error');
                return;
            }

            // Pre-fill event form with search query as title
            document.getElementById('eventTitle').value = query;
            
            // Try to extract date/time information from the query
            const dateTimePattern = /(\d{1,2}\/\d{1,2}\/\d{2,4}|\d{4}-\d{2}-\d{2}|\b(?:tomorrow|today|next week|next month)\b)/gi;
            const timePattern = /(\d{1,2}:\d{2}\s*(?:am|pm)?|\b(?:morning|afternoon|evening|night)\b)/gi;
            
            const dateMatch = query.match(dateTimePattern);
            const timeMatch = query.match(timePattern);
            
            if (dateMatch || timeMatch) {
                try {
                    let dateStr = '';
                    if (dateMatch) {
                        dateStr = dateMatch[0];
                        if (dateStr.toLowerCase() === 'today') {
                            dateStr = new Date().toISOString().split('T')[0];
                        } else if (dateStr.toLowerCase() === 'tomorrow') {
                            const tomorrow = new Date();
                            tomorrow.setDate(tomorrow.getDate() + 1);
                            dateStr = tomorrow.toISOString().split('T')[0];
                        }
                    }
                    
                    let timeStr = '';
                    if (timeMatch) {
                        timeStr = timeMatch[0];
                        if (timeStr.toLowerCase() === 'morning') timeStr = '09:00';
                        else if (timeStr.toLowerCase() === 'afternoon') timeStr = '14:00';
                        else if (timeStr.toLowerCase() === 'evening') timeStr = '18:00';
                        else if (timeStr.toLowerCase() === 'night') timeStr = '20:00';
                    }
                    
                    if (dateStr && timeStr) {
                        const combinedDateTime = `${dateStr}T${timeStr}`;
                        document.getElementById('eventDateTime').value = combinedDateTime;
                    } else if (dateStr) {
                        document.getElementById('eventDateTime').value = `${dateStr}T09:00`;
                    }
                } catch (error) {
                    console.log('Could not parse date/time from query:', error);
                }
            }

            // Show notification and scroll to form
            showNotification('📅 Event form pre-filled from search! Complete the details and click "Add Event"', 'success');
            document.getElementById('eventForm').scrollIntoView({ behavior: 'smooth' });
        }

        // Open Personalized Analytics Report (from burger menu)
        async function openPersonalizedReport() {
            // Close sidebar
            closeSidebar();
            
            // Create modal for comprehensive report
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 900px; max-height: 85vh; overflow-y: auto;">
                    <span class="close" onclick="this.parentElement.parentElement.remove()">&times;</span>
                    <h2 style="color: var(--cyber-purple); text-align: center; margin-bottom: 25px;">📊 Your Personalized Analytics Report</h2>
                    
                    <div id="comprehensiveReportContainer">
                        <p style="text-align: center; color: #999;">Generating your comprehensive report...</p>
                    </div>
                    
                    <div style="text-align: center; margin-top: 20px; padding-top: 15px; border-top: 1px solid rgba(100, 150, 200, 0.3);">
                        <button onclick="refreshComprehensiveReport()" class="cyber-button" style="margin-right: 10px;">
                            🔄 Refresh Report
                        </button>
                        <button onclick="generatePersonalizedNewsletter()" class="cyber-button" style="background: linear-gradient(45deg, var(--cyber-orange), var(--cyber-pink));">
                            📧 Generate Newsletter
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Generate the comprehensive report
            await generateComprehensiveReport();
        }

        // Generate comprehensive personalized report
        async function generateComprehensiveReport() {
            const container = document.getElementById('comprehensiveReportContainer');
            if (!container) return;

            // Show loading state
            container.innerHTML = '<p style="text-align: center; color: #999;">Generating your comprehensive report...</p>';

            const searchHistory = getSearchHistory();
            const favorites = await getFavorites(); // Now async
            const eventTracking = JSON.parse(localStorage.getItem('eventTracking') || '{}');

            console.log('📊 Report data:', { 
                searchHistory: searchHistory.length, 
                favorites: favorites.length, 
                eventTracking: Object.keys(eventTracking).length 
            });

            // Analyze user data
            const insights = analyzeUserBehavior(searchHistory, favorites, eventTracking);
            const recommendations = generatePersonalizedRecommendations(insights);

            const reportHTML = `
                <div style="line-height: 1.6;">
                    <!-- User Overview -->
                    <div class="analytics-card" style="margin-bottom: 20px;">
                        <h3 style="color: var(--cyber-blue); margin-bottom: 15px;">👤 Your Activity Overview</h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            <div class="analytics-stat">
                                <span>Total Searches:</span>
                                <strong style="color: var(--cyber-green);">${searchHistory.length}</strong>
                            </div>
                            <div class="analytics-stat">
                                <span>Favorite Events:</span>
                                <strong style="color: var(--cyber-pink);">${favorites.length}</strong>
                            </div>
                            <div class="analytics-stat">
                                <span>Events Attended:</span>
                                <strong style="color: var(--cyber-orange);">${Object.values(eventTracking).filter(s => s === 'attended').length}</strong>
                            </div>
                            <div class="analytics-stat">
                                <span>Activity Level:</span>
                                <strong style="color: var(--cyber-purple);">${insights.activityLevel}</strong>
                            </div>
                        </div>
                    </div>

                    <!-- Recommended Events -->
                    <div class="analytics-card" style="margin-bottom: 20px;">
                        <h3 style="color: var(--cyber-green); margin-bottom: 15px;">🎯 Recommended Events for You</h3>
                        <div style="background: rgba(0, 200, 100, 0.05); padding: 15px; border-radius: 8px;">
                            ${recommendations.events.map(event => `
                                <div style="border-bottom: 1px solid rgba(0, 200, 100, 0.2); padding: 12px 0;">
                                    <h4 style="color: var(--cyber-blue); margin: 0;">${event.title}</h4>
                                    <p style="color: #ccc; margin: 5px 0; font-size: 0.9rem;">${event.description}</p>
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                                        <span style="color: var(--cyber-orange); font-size: 0.85rem;">
                                            📍 ${event.location} • ⏰ ${event.time}
                                        </span>
                                        <span style="color: var(--cyber-green); font-size: 0.8rem; background: rgba(0, 200, 100, 0.15); padding: 4px 8px; border-radius: 12px;">
                                            ${event.category}
                                        </span>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    <!-- Research & Articles -->
                    <div class="analytics-card" style="margin-bottom: 20px;">
                        <h3 style="color: var(--cyber-orange); margin-bottom: 15px;">📚 Recommended Research & Articles</h3>
                        <div style="background: rgba(255, 107, 0, 0.05); padding: 15px; border-radius: 8px;">
                            ${recommendations.research.map(item => `
                                <div style="border-bottom: 1px solid rgba(255, 107, 0, 0.2); padding: 12px 0;">
                                    <h4 style="color: var(--cyber-blue); margin: 0;">${item.title}</h4>
                                    <p style="color: #ccc; margin: 5px 0; font-size: 0.9rem;">${item.description}</p>
                                    <div style="margin-top: 8px;">
                                        <a href="${item.url}" target="_blank" style="color: var(--cyber-green); text-decoration: none; font-size: 0.85rem;">
                                            🔗 Read More (${item.source})
                                        </a>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    <!-- Reddit Threads -->
                    <div class="analytics-card" style="margin-bottom: 20px;">
                        <h3 style="color: var(--cyber-pink); margin-bottom: 15px;">💬 Relevant Reddit Discussions</h3>
                        <div style="background: rgba(255, 0, 128, 0.05); padding: 15px; border-radius: 8px;">
                            ${recommendations.reddit.map(thread => `
                                <div style="border-bottom: 1px solid rgba(255, 0, 128, 0.2); padding: 12px 0;">
                                    <h4 style="color: var(--cyber-blue); margin: 0;">${thread.title}</h4>
                                    <p style="color: #ccc; margin: 5px 0; font-size: 0.9rem;">${thread.description}</p>
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                                        <a href="${thread.url}" target="_blank" style="color: var(--cyber-green); text-decoration: none; font-size: 0.85rem;">
                                            🔗 Join Discussion
                                        </a>
                                        <span style="color: var(--cyber-pink); font-size: 0.8rem;">
                                            r/${thread.subreddit} • ${thread.engagement}
                                        </span>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    <!-- GitHub Repositories -->
                    <div class="analytics-card" style="margin-bottom: 20px;">
                        <h3 style="color: var(--cyber-purple); margin-bottom: 15px;">💻 Recommended GitHub Projects</h3>
                        <div style="background: rgba(139, 0, 255, 0.05); padding: 15px; border-radius: 8px;">
                            ${recommendations.github.map(repo => `
                                <div style="border-bottom: 1px solid rgba(139, 0, 255, 0.2); padding: 12px 0;">
                                    <h4 style="color: var(--cyber-blue); margin: 0;">${repo.title}</h4>
                                    <p style="color: #ccc; margin: 5px 0; font-size: 0.9rem;">${repo.description}</p>
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                                        <a href="${repo.url}" target="_blank" style="color: var(--cyber-green); text-decoration: none; font-size: 0.85rem;">
                                            🔗 View Repository
                                        </a>
                                        <span style="color: var(--cyber-purple); font-size: 0.8rem;">
                                            ⭐ ${repo.stars} • ${repo.language}
                                        </span>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    <!-- Personalized Insights -->
                    <div class="analytics-card">
                        <h3 style="color: var(--cyber-blue); margin-bottom: 15px;">💡 Your Personalized Insights</h3>
                        <div style="background: rgba(0, 150, 200, 0.05); padding: 15px; border-radius: 8px; font-size: 0.95rem;">
                            ${insights.personalizedInsights}
                        </div>
                    </div>
                </div>
            `;

            container.innerHTML = reportHTML;
        }

        // Analyze user behavior comprehensively
        function analyzeUserBehavior(searchHistory, favorites, eventTracking) {
            const insights = {
                activityLevel: 'Light',
                topInterests: [],
                preferredCategories: [],
                timePatterns: {},
                locationPatterns: {},
                personalizedInsights: ''
            };

            // Determine activity level
            const totalActivity = searchHistory.length + favorites.length;
            if (totalActivity > 20) insights.activityLevel = 'Very Active';
            else if (totalActivity > 10) insights.activityLevel = 'Active';
            else if (totalActivity > 5) insights.activityLevel = 'Moderate';

            // Extract interests from search history
            const interests = {};
            searchHistory.forEach(search => {
                const words = search.query.toLowerCase().split(' ').filter(word => word.length > 3);
                words.forEach(word => {
                    interests[word] = (interests[word] || 0) + 1;
                });
            });
            insights.topInterests = Object.entries(interests)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 5)
                .map(([interest]) => interest);

            // Generate personalized insights
            const attendanceRate = Object.values(eventTracking).filter(s => s === 'attended').length;
            const wishlistCount = Object.values(eventTracking).filter(s => s === 'wishlist').length;

            let insightText = `Based on your activity, you're a ${insights.activityLevel.toLowerCase()} user who `;
            
            if (insights.topInterests.length > 0) {
                insightText += `shows strong interest in ${insights.topInterests.slice(0, 3).join(', ')}. `;
            }
            
            if (attendanceRate > 0) {
                insightText += `You've attended ${attendanceRate} events, showing good follow-through on your interests. `;
            }
            
            if (wishlistCount > 0) {
                insightText += `You have ${wishlistCount} events on your wishlist - consider making time for these! `;
            }
            
            insightText += 'Keep exploring to discover more opportunities that match your interests.';
            insights.personalizedInsights = insightText;

            return insights;
        }

        // Generate personalized recommendations
        function generatePersonalizedRecommendations(insights) {
            const recommendations = {
                events: [],
                research: [],
                reddit: [],
                github: []
            };

            // Generate event recommendations based on interests
            const eventCategories = {
                'tech': { category: 'Technology', location: 'Tech Hub, Local Area', time: 'Weekends' },
                'music': { category: 'Music', location: 'Concert Hall, Downtown', time: 'Evenings' },
                'food': { category: 'Food & Drink', location: 'Local Restaurants', time: 'Lunch/Dinner' },
                'business': { category: 'Professional', location: 'Business District', time: 'After Work' },
                'art': { category: 'Arts & Culture', location: 'Art Gallery, Museum', time: 'Weekends' }
            };

            insights.topInterests.forEach((interest, index) => {
                if (index < 3) {
                    const category = eventCategories[interest] || { category: 'General', location: 'Local Area', time: 'Various' };
                    recommendations.events.push({
                        title: `${interest.charAt(0).toUpperCase() + interest.slice(1)} Meetup`,
                        description: `Local ${interest} enthusiasts gathering to share knowledge and network.`,
                        location: category.location,
                        time: category.time,
                        category: category.category
                    });
                }
            });

            // Generate research recommendations
            insights.topInterests.forEach((interest, index) => {
                if (index < 3) {
                    recommendations.research.push({
                        title: `Latest Trends in ${interest.charAt(0).toUpperCase() + interest.slice(1)}`,
                        description: `Research articles and papers covering recent developments and future outlook.`,
                        url: `https://scholar.google.com/scholar?q=${interest}+trends+2025`,
                        source: 'Google Scholar'
                    });
                }
            });

            // Generate Reddit thread recommendations
            insights.topInterests.forEach((interest, index) => {
                if (index < 3) {
                    recommendations.reddit.push({
                        title: `r/${interest} - Active Discussions`,
                        description: `Join ongoing conversations and get answers from the ${interest} community.`,
                        url: `https://reddit.com/r/${interest}`,
                        subreddit: interest,
                        engagement: 'High Activity'
                    });
                }
            });

            // Generate GitHub recommendations
            insights.topInterests.forEach((interest, index) => {
                if (index < 3) {
                    recommendations.github.push({
                        title: `${interest.charAt(0).toUpperCase() + interest.slice(1)} Projects`,
                        description: `Open source projects and tools related to ${interest} development.`,
                        url: `https://github.com/search?q=${interest}&type=repositories&s=stars&o=desc`,
                        stars: '1k+',
                        language: 'Various'
                    });
                }
            });

            return recommendations;
        }

        // Refresh comprehensive report
        async function refreshComprehensiveReport() {
            await generateComprehensiveReport();
            showNotification('📊 Report refreshed with latest data!', 'success');
        }

        // Generate personalized newsletter from report
        async function generatePersonalizedNewsletter() {
            await generateNewsletterPreview();
            showNotification('📧 Newsletter preview updated based on your report!', 'success');
        }

        // Initialize Google Calendar API when page loads
        // (Authentication and page initialization handled in main DOMContentLoaded listener above)
    </script>
</body>
</html>