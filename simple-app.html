<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Prospector - Cyberpunk Interface</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --cyber-blue: #00ffff;
            --cyber-pink: #ff0080;
            --cyber-green: #00ff41;
            --cyber-orange: #ff6b00;
            --cyber-purple: #8b00ff;
            --dark-bg: #0a0a0a;
            --darker-bg: #050505;
        }

        body {
            font-family: 'Share Tech Mono', monospace;
            background: var(--dark-bg);
            color: var(--cyber-blue);
            overflow-x: hidden;
            min-height: 100vh;
            position: relative;
        }

        /* Animated Grid Background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridMove 20s linear infinite;
            z-index: -2;
        }

        @keyframes gridMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }

        /* Particle Effects */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: var(--cyber-blue);
            border-radius: 50%;
            animation: float 6s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { 
                transform: translateY(100vh) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) scale(1);
                opacity: 0;
            }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            position: relative;
        }

        .title {
            font-family: 'Orbitron', monospace;
            font-size: 3.5rem;
            font-weight: 900;
            background: linear-gradient(45deg, var(--cyber-blue), var(--cyber-pink), var(--cyber-green));
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            margin-bottom: 10px;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .subtitle {
            font-size: 1.2rem;
            color: var(--cyber-green);
            text-transform: uppercase;
            letter-spacing: 3px;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        .search-section {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(0, 255, 255, 0.1));
            border: 2px solid var(--cyber-blue);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }

        .search-section::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, var(--cyber-blue), var(--cyber-pink), var(--cyber-green), var(--cyber-orange));
            border-radius: 15px;
            z-index: -1;
            animation: borderGlow 3s linear infinite;
        }

        @keyframes borderGlow {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }

        .input-group {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .cyber-input {
            flex: 1;
            min-width: 250px;
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--cyber-blue);
            border-radius: 10px;
            color: var(--cyber-blue);
            font-family: 'Share Tech Mono', monospace;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .cyber-input:focus {
            outline: none;
            border-color: var(--cyber-pink);
            box-shadow: 0 0 20px rgba(255, 0, 128, 0.5);
            transform: translateY(-2px);
        }

        .cyber-button {
            padding: 15px 30px;
            background: linear-gradient(45deg, var(--cyber-blue), var(--cyber-green));
            border: none;
            border-radius: 10px;
            color: black;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .cyber-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .cyber-button:hover::before {
            left: 100%;
        }

        .cyber-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 255, 255, 0.4);
        }

        .results-section {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--cyber-green);
            border-radius: 15px;
            padding: 30px;
            min-height: 300px;
        }

        .results-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.8rem;
            color: var(--cyber-green);
            margin-bottom: 20px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .result-item {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(255, 0, 128, 0.05));
            border: 1px solid var(--cyber-blue);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
            position: relative;
        }

        .result-item:hover {
            transform: translateX(10px);
            border-color: var(--cyber-pink);
            box-shadow: -5px 0 15px rgba(255, 0, 128, 0.3);
        }

        .result-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.2rem;
            color: var(--cyber-blue);
            margin-bottom: 10px;
        }

        .result-link {
            color: var(--cyber-green);
            text-decoration: none;
            word-break: break-all;
            transition: color 0.3s ease;
        }

        .result-link:hover {
            color: var(--cyber-pink);
            text-shadow: 0 0 5px rgba(255, 0, 128, 0.5);
        }

        .result-snippet {
            color: #ccc;
            margin-top: 10px;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .loading {
            text-align: center;
            font-size: 1.2rem;
            color: var(--cyber-orange);
            animation: loadingPulse 1.5s ease-in-out infinite;
        }

        @keyframes loadingPulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        .archive-section {
            background: rgba(139, 0, 255, 0.1);
            border: 2px solid var(--cyber-purple);
            border-radius: 15px;
            padding: 30px;
            margin-top: 30px;
        }

        .archive-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.8rem;
            color: var(--cyber-purple);
            margin-bottom: 20px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .archive-item {
            background: rgba(139, 0, 255, 0.1);
            border: 1px solid var(--cyber-purple);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .archive-item:hover {
            background: rgba(139, 0, 255, 0.2);
            transform: translateX(5px);
        }

        .archive-query {
            color: var(--cyber-purple);
            font-weight: bold;
            margin-bottom: 5px;
        }

        .archive-date {
            color: #888;
            font-size: 0.8rem;
        }

        /* Glitch Effect */
        .glitch {
            position: relative;
            animation: glitch 2s infinite;
        }

        @keyframes glitch {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .title {
                font-size: 2.5rem;
            }
            
            .input-group {
                flex-direction: column;
            }
            
            .cyber-input {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="particles" id="particles"></div>
    
    <div class="container">
        <header class="header">
            <h1 class="title glitch">THE PROSPECTOR</h1>
            <p class="subtitle">Community Event Discovery Network v3.0</p>
        </header>

        <section class="search-section">
            <h2 class="results-title" style="margin-bottom: 20px;">Multi-Platform Search</h2>
            <div class="input-group">
                <input type="text" id="searchQuery" class="cyber-input" placeholder="Search GitHub repos, Reddit posts, and more..." required />
                <input type="url" id="urlInput" class="cyber-input" placeholder="Optional: Enter URL to scrape..." />
                <button onclick="generalSearch()" class="cyber-button">Search All</button>
            </div>
            <div class="input-group" style="justify-content: center;">
                <small style="color: var(--cyber-green); text-align: center;">
                    üîç Searches across GitHub repositories, Reddit posts, and local content
                </small>
            </div>
        </section>

        <section class="search-section">
            <h2 class="results-title" style="margin-bottom: 20px;">Event Discovery</h2>
            <div class="input-group">
                <input type="text" id="locationInput" class="cyber-input" placeholder="Enter location (city, state, zip)..." required />
                <select id="genreSelect" class="cyber-input" style="min-width: 200px;">
                    <option value="">All Genres</option>
                    <option value="tech">Technology & Tech Meetups</option>
                    <option value="business">Business & Networking</option>
                    <option value="arts">Arts & Culture</option>
                    <option value="music">Music & Concerts</option>
                    <option value="sports">Sports & Fitness</option>
                    <option value="food">Food & Drink</option>
                    <option value="gaming">Gaming & Esports</option>
                    <option value="education">Education & Learning</option>
                    <option value="health">Health & Wellness</option>
                    <option value="social">Social & Community</option>
                    <option value="outdoor">Outdoor & Adventure</option>
                    <option value="creative">Creative & DIY</option>
                    <option value="professional">Professional Development</option>
                    <option value="charity">Volunteer & Charity</option>
                </select>
            </div>
            <div class="input-group">
                <select id="eventTypeSelect" class="cyber-input" style="min-width: 200px;">
                    <option value="">All Event Types</option>
                    <option value="meetup">Meetups & Groups</option>
                    <option value="workshop">Workshops & Classes</option>
                    <option value="conference">Conferences & Seminars</option>
                    <option value="networking">Networking Events</option>
                    <option value="social">Social Gatherings</option>
                    <option value="online">Online Events</option>
                    <option value="festival">Festivals & Fairs</option>
                    <option value="concert">Concerts & Shows</option>
                    <option value="sports">Sports Events</option>
                    <option value="volunteer">Volunteer Opportunities</option>
                </select>
                <select id="timeframeSelect" class="cyber-input" style="min-width: 150px;">
                    <option value="immediate">Happening Now</option>
                    <option value="tonight">Tonight</option>
                    <option value="upcoming">This Week</option>
                    <option value="general">Any Time</option>
                </select>
                <input type="number" id="radiusInput" class="cyber-input" placeholder="Radius (miles)" value="25" min="1" max="100" style="max-width: 120px;" />
            </div>
            <div class="input-group">
                <button onclick="searchEvents()" class="cyber-button">Find Events</button>
                <button onclick="discoverEventsNow()" class="cyber-button" style="background: linear-gradient(45deg, var(--cyber-orange), var(--cyber-pink));">Discover Now</button>
                <button onclick="loadNearbyEvents()" class="cyber-button" style="background: linear-gradient(45deg, var(--cyber-purple), var(--cyber-blue));">Use Location</button>
                <button onclick="clearResults()" class="cyber-button" style="background: linear-gradient(45deg, var(--cyber-pink), var(--cyber-orange));">Clear</button>
            </div>
        </section>

        <section class="results-section">
            <h2 class="results-title">Community Events Found</h2>
            <div id="results">
                <p style="text-align: center; color: #666;">Enter location and preferences to discover events...</p>
            </div>
        </section>

        <section class="archive-section">
            <h2 class="archive-title">Event Search History</h2>
            <div id="archive">
                <p style="text-align: center; color: #666;">No previous event searches...</p>
            </div>
        </section>
    </div>

    <script>
        // API Configuration for GitHub and Reddit integration
        const API_CONFIG = {
            github: {
                token: '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',
                baseUrl: 'https://api.github.com'
            },
            reddit: {
                clientId: '6WvFTgrgGLXjqOyXGRSlZQ',
                clientSecret: 'jb3MA8zQxBllZIVPV6PtqkFrut-m-g',
                userAgent: 'wild west prospector scraper v1.0',
                redirectUri: 'http://localhost:8080',
                baseUrl: 'https://www.reddit.com/api/v1'
            }
        };

        // ADVANCED FEATURES THAT CHATGPT CANNOT DO
        
        // 1. Real-time Code Vulnerability Scanner
        async function analyzeCodeVulnerabilities(repoUrl) {
            try {
                // Extract repo info from URL
                const repoMatch = repoUrl.match(/github\.com\/([^\/]+)\/([^\/]+)/);
                if (!repoMatch) return null;
                
                const [, owner, repo] = repoMatch;
                
                // Get repository contents
                const contentsResponse = await fetch(`${API_CONFIG.github.baseUrl}/repos/${owner}/${repo}/contents`, {
                    headers: {
                        'Authorization': `token ${API_CONFIG.github.token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });
                
                if (!contentsResponse.ok) return null;
                const contents = await contentsResponse.json();
                
                // Analyze for common vulnerabilities
                const vulnerabilities = [];
                const securityFiles = ['package.json', 'requirements.txt', 'Gemfile', 'pom.xml'];
                
                for (const file of contents) {
                    if (securityFiles.includes(file.name)) {
                        const fileResponse = await fetch(file.download_url);
                        const fileContent = await fileResponse.text();
                        
                        // Check for known vulnerable patterns
                        if (file.name === 'package.json') {
                            const vulnPatterns = ['eval(', 'innerHTML', 'document.write', 'exec('];
                            vulnPatterns.forEach(pattern => {
                                if (fileContent.includes(pattern)) {
                                    vulnerabilities.push(`Potential XSS/Code Injection: ${pattern} found in ${file.name}`);
                                }
                            });
                        }
                    }
                }
                
                return {
                    repo: `${owner}/${repo}`,
                    vulnerabilities,
                    securityScore: Math.max(0, 100 - (vulnerabilities.length * 20))
                };
            } catch (error) {
                console.error('Vulnerability analysis error:', error);
                return null;
            }
        }

        // 2. AI-Powered Sentiment Analysis for Repositories
        async function analyzeSentiment(repoUrl) {
            try {
                const repoMatch = repoUrl.match(/github\.com\/([^\/]+)\/([^\/]+)/);
                if (!repoMatch) return null;
                
                const [, owner, repo] = repoMatch;
                
                // Get issues and PRs for sentiment analysis
                const issuesResponse = await fetch(`${API_CONFIG.github.baseUrl}/repos/${owner}/${repo}/issues?state=all&per_page=20`, {
                    headers: {
                        'Authorization': `token ${API_CONFIG.github.token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });
                
                if (!issuesResponse.ok) return null;
                const issues = await issuesResponse.json();
                
                // Simple sentiment analysis
                const positiveWords = ['good', 'great', 'awesome', 'excellent', 'love', 'perfect', 'amazing', 'fantastic'];
                const negativeWords = ['bad', 'terrible', 'awful', 'hate', 'broken', 'bug', 'issue', 'problem', 'error'];
                
                let positiveCount = 0;
                let negativeCount = 0;
                let totalWords = 0;
                
                issues.forEach(issue => {
                    const text = (issue.title + ' ' + (issue.body || '')).toLowerCase();
                    const words = text.split(/\s+/);
                    totalWords += words.length;
                    
                    words.forEach(word => {
                        if (positiveWords.includes(word)) positiveCount++;
                        if (negativeWords.includes(word)) negativeCount++;
                    });
                });
                
                const sentimentScore = ((positiveCount - negativeCount) / totalWords * 100).toFixed(2);
                
                return {
                    repo: `${owner}/${repo}`,
                    sentiment: sentimentScore > 0 ? 'Positive' : sentimentScore < 0 ? 'Negative' : 'Neutral',
                    score: sentimentScore,
                    analysisData: {
                        totalIssues: issues.length,
                        positiveKeywords: positiveCount,
                        negativeKeywords: negativeCount
                    }
                };
            } catch (error) {
                console.error('Sentiment analysis error:', error);
                return null;
            }
        }

        // 3. Cross-Platform Data Mining & Correlation Engine
        async function performDataMining(query) {
            try {
                const results = {
                    github: await mineGitHubData(query),
                    reddit: await mineRedditData(query),
                    correlations: []
                };
                
                // Find correlations between platforms
                if (results.github && results.reddit) {
                    const commonTopics = findCommonTopics(results.github.topics, results.reddit.topics);
                    results.correlations = commonTopics;
                }
                
                return results;
            } catch (error) {
                console.error('Data mining error:', error);
                return null;
            }
        }

        async function mineGitHubData(query) {
            const response = await fetch(`${API_CONFIG.github.baseUrl}/search/repositories?q=${encodeURIComponent(query)}&sort=stars&per_page=50`, {
                headers: {
                    'Authorization': `token ${API_CONFIG.github.token}`,
                    'Accept': 'application/vnd.github.v3+json'
                }
            });
            
            if (!response.ok) return null;
            const data = await response.json();
            
            // Extract topics and analyze trends
            const topics = [];
            const languages = {};
            
            data.items.forEach(repo => {
                if (repo.topics) topics.push(...repo.topics);
                if (repo.language) {
                    languages[repo.language] = (languages[repo.language] || 0) + 1;
                }
            });
            
            return {
                totalRepos: data.items.length,
                topics: [...new Set(topics)],
                languages,
                trends: analyzeTrends(data.items)
            };
        }

        async function mineRedditData(query) {
            try {
                const response = await fetch(`https://www.reddit.com/search.json?q=${encodeURIComponent(query)}&limit=50&sort=hot`);
                if (!response.ok) return null;
                
                const data = await response.json();
                const posts = data.data.children;
                
                const subreddits = {};
                const topics = [];
                
                posts.forEach(post => {
                    const subreddit = post.data.subreddit;
                    subreddits[subreddit] = (subreddits[subreddit] || 0) + 1;
                    
                    // Extract topics from titles
                    const titleWords = post.data.title.toLowerCase().split(/\s+/);
                    topics.push(...titleWords.filter(word => word.length > 3));
                });
                
                return {
                    totalPosts: posts.length,
                    subreddits,
                    topics: [...new Set(topics)],
                    engagement: calculateEngagement(posts)
                };
            } catch (error) {
                console.error('Reddit mining error:', error);
                return null;
            }
        }

        function findCommonTopics(githubTopics, redditTopics) {
            return githubTopics.filter(topic => redditTopics.includes(topic));
        }

        function analyzeTrends(repos) {
            // Analyze creation dates, star growth, etc.
            const trends = {
                recentActivity: 0,
                growingRepos: 0,
                averageStars: 0
            };
            
            repos.forEach(repo => {
                const createdDate = new Date(repo.created_at);
                const monthsOld = (Date.now() - createdDate.getTime()) / (1000 * 60 * 60 * 24 * 30);
                
                if (monthsOld < 6) trends.recentActivity++;
                if (repo.stargazers_count > 100) trends.growingRepos++;
                trends.averageStars += repo.stargazers_count;
            });
            
            trends.averageStars = Math.round(trends.averageStars / repos.length);
            return trends;
        }

        function calculateEngagement(posts) {
            let totalScore = 0;
            let totalComments = 0;
            
            posts.forEach(post => {
                totalScore += post.data.score || 0;
                totalComments += post.data.num_comments || 0;
            });
            
            return {
                averageScore: Math.round(totalScore / posts.length),
                averageComments: Math.round(totalComments / posts.length),
                engagementRate: Math.round((totalComments / totalScore) * 100) || 0
            };
        }

        // 4. Advanced Web Scraping with Content Extraction
        async function advancedScraper(url) {
            try {
                const response = await fetch('/api/scrape', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        url,
                        advanced: true,
                        extractEmails: true,
                        extractLinks: true,
                        extractImages: true,
                        extractMetadata: true
                    })
                });
                
                if (!response.ok) throw new Error('Scraping failed');
                return await response.json();
            } catch (error) {
                console.error('Advanced scraping error:', error);
                return null;
            }
        }

        // 5. Trend Prediction Engine
        class TrendPredictor {
            static async predictTrends(data) {
                // Simple trend prediction based on data patterns
                const predictions = {
                    emergingTopics: [],
                    decliningTopics: [],
                    futureGrowth: 0,
                    confidence: 0
                };
                
                if (data.github && data.reddit) {
                    // Analyze growth patterns
                    const githubTrends = data.github.trends;
                    const redditEngagement = data.reddit.engagement;
                    
                    // Predict based on recent activity and engagement
                    predictions.futureGrowth = (githubTrends.recentActivity + redditEngagement.engagementRate) / 2;
                    predictions.confidence = Math.min(95, predictions.futureGrowth * 1.2);
                    
                    // Identify emerging topics (high GitHub activity + Reddit discussions)
                    if (data.correlations && data.correlations.length > 0) {
                        predictions.emergingTopics = data.correlations.slice(0, 5);
                    }
                }
                
                return predictions;
            }
        }

        // Enhanced GitHub API with robust error handling and retry logic
        async function searchGitHub(query, retries = 3) {
            for (let attempt = 0; attempt < retries; attempt++) {
                try {
                    const response = await fetch(`${API_CONFIG.github.baseUrl}/search/repositories?q=${encodeURIComponent(query)}&sort=stars&per_page=20`, {
                        headers: {
                            'Authorization': `token ${API_CONFIG.github.token}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'User-Agent': 'The-Prospector-App',
                            'X-GitHub-Api-Version': '2022-11-28'
                        }
                    });
                    
                    if (response.status === 403) {
                        // Rate limit hit, wait and retry
                        const resetTime = response.headers.get('X-RateLimit-Reset');
                        if (resetTime) {
                            const waitTime = (parseInt(resetTime) * 1000) - Date.now();
                            if (waitTime > 0 && waitTime < 60000) { // Wait max 1 minute
                                console.log(`Rate limited, waiting ${waitTime}ms`);
                                await new Promise(resolve => setTimeout(resolve, waitTime));
                                continue;
                            }
                        }
                    }
                    
                    if (!response.ok) {
                        throw new Error(`GitHub API Error: ${response.status} - ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    console.log('GitHub API success:', data.total_count, 'repositories found');
                    return data;
                    
                } catch (error) {
                    console.error(`GitHub attempt ${attempt + 1} failed:`, error);
                    if (attempt === retries - 1) {
                        throw error;
                    }
                    // Wait before retry
                    await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));
                }
            }
        }

        // Enhanced Reddit API with multiple fallback strategies
        // Enhanced Reddit search with working CORS proxy
        async function searchReddit(query, subreddit = '', retries = 3) {
            // Input validation
            if (!query || typeof query !== 'string') {
                console.error('Invalid query provided to searchReddit:', query);
                return null;
            }
            
            const cleanQuery = query.trim();
            if (!cleanQuery) {
                console.error('Empty query after cleaning');
                return null;
            }

            console.log(`üîç Searching Reddit for: "${cleanQuery}"`);

            try {
                // Use pushshift.io API as it's more reliable for searches
                const pushShiftUrl = `https://api.pushshift.io/reddit/search/submission/?q=${encodeURIComponent(cleanQuery)}&size=25&sort=desc`;
                console.log('Trying Pushshift API:', pushShiftUrl);
                
                const response = await fetch(pushShiftUrl);
                
                if (response.ok) {
                    const pushShiftData = await response.json();
                    
                    if (pushShiftData.data && pushShiftData.data.length > 0) {
                        // Convert pushshift format to Reddit format
                        const redditFormatData = {
                            data: {
                                children: pushShiftData.data.map(post => ({
                                    data: {
                                        title: post.title || 'No title',
                                        url: post.url || `https://reddit.com/r/${post.subreddit}/comments/${post.id}/`,
                                        permalink: `/r/${post.subreddit}/comments/${post.id}/`,
                                        subreddit: post.subreddit || 'unknown',
                                        score: post.score || 0,
                                        num_comments: post.num_comments || 0,
                                        selftext: post.selftext || '',
                                        author: post.author || 'unknown',
                                        created_utc: post.created_utc || 0
                                    }
                                }))
                            }
                        };
                        
                        console.log(`‚úÖ Pushshift API success: ${redditFormatData.data.children.length} posts found`);
                        return redditFormatData;
                    }
                }
                
                console.log('Pushshift API failed, trying Reddit JSON API with CORS proxy...');
                
                // Fallback to Reddit JSON API with CORS proxy
                let redditUrl;
                if (subreddit) {
                    redditUrl = `https://www.reddit.com/r/${encodeURIComponent(subreddit)}/search.json?q=${encodeURIComponent(cleanQuery)}&limit=25&sort=relevance&t=all`;
                } else {
                    redditUrl = `https://www.reddit.com/search.json?q=${encodeURIComponent(cleanQuery)}&limit=25&sort=hot&t=all`;
                }
                
                // Try with a reliable CORS proxy
                const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(redditUrl)}`;
                console.log('Trying CORS proxy:', proxyUrl);
                
                const proxyResponse = await fetch(proxyUrl);
                
                if (proxyResponse.ok) {
                    const data = await proxyResponse.json();
                    
                    if (data && data.data && Array.isArray(data.data.children)) {
                        console.log(`‚úÖ Reddit JSON API success: ${data.data.children.length} posts found`);
                        return data;
                    }
                }
                
                console.log('CORS proxy failed, trying alternative proxy...');
                
                // Try alternative proxy
                const altProxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(redditUrl)}`;
                const altResponse = await fetch(altProxyUrl);
                
                if (altResponse.ok) {
                    const altData = await altResponse.json();
                    
                    if (altData.contents) {
                        try {
                            const parsedData = JSON.parse(altData.contents);
                            if (parsedData && parsedData.data && Array.isArray(parsedData.data.children)) {
                                console.log(`‚úÖ Alternative proxy success: ${parsedData.data.children.length} posts found`);
                                return parsedData;
                            }
                        } catch (parseError) {
                            console.error('Failed to parse alternative proxy response:', parseError);
                        }
                    }
                }
                
            } catch (error) {
                console.error('Reddit search error:', error);
            }
            
            // Final fallback: return mock data structure
            console.log('‚ö†Ô∏è All Reddit strategies failed, returning fallback data');
            return {
                data: {
                    children: [{
                        data: {
                            title: `Reddit Search: "${cleanQuery}"`,
                            url: `https://www.reddit.com/search?q=${encodeURIComponent(cleanQuery)}`,
                            permalink: `/search?q=${encodeURIComponent(cleanQuery)}`,
                            subreddit: 'search',
                            score: 0,
                            num_comments: 0,
                            selftext: 'Reddit search temporarily unavailable. Click to search manually on Reddit.',
                            author: 'system',
                            created_utc: Date.now() / 1000
                        }
                    }]
                }
            };
        }

        // Create floating particles
        function createParticles() {
            const particleContainer = document.getElementById('particles');
            const colors = ['#00ffff', '#ff0080', '#00ff41', '#ff6b00', '#8b00ff'];
            
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 6 + 's';
                particle.style.animationDuration = (Math.random() * 3 + 3) + 's';
                particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                particleContainer.appendChild(particle);
            }
        }

        // Enhanced event search function
        async function searchEvents() {
            const location = document.getElementById('locationInput').value.trim();
            const genre = document.getElementById('genreSelect').value;
            const eventType = document.getElementById('eventTypeSelect').value;
            const timeframe = document.getElementById('timeframeSelect').value;
            const radius = document.getElementById('radiusInput').value || 25;
            
            if (!location) {
                alert('Please enter a location');
                return;
            }

            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<div class="loading">Scanning event networks...</div>';

            try {
                const requestBody = { 
                    location, 
                    genre: genre || undefined, 
                    eventType: eventType || undefined,
                    timeframe: timeframe || 'upcoming',
                    radius: parseInt(radius) 
                };

                const response = await fetch('/api/search-events', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                displayEnhancedResults(data);
                
                // Save the search
                await saveEventSearch(data);
                loadArchive();
            } catch (error) {
                console.error('Event search error:', error);
                resultsDiv.innerHTML = '<div style="color: var(--cyber-pink); text-align: center;">Event search failed. Check network connection.</div>';
            }
        }

        // Enhanced general search function with GitHub and Reddit integration
        async function generalSearch() {
            const query = document.getElementById('searchQuery').value.trim();
            const url = document.getElementById('urlInput').value.trim();
            
            if (!query) {
                alert('Please enter a search query');
                return;
            }

            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<div class="loading">Searching across multiple platforms...</div>';

            try {
                const allResults = [];

                // Search local API
                try {
                    const requestBody = { query };
                    if (url) {
                        requestBody.url = url;
                    }

                    const response = await fetch('/api/search', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(requestBody)
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.results && data.results.length > 0) {
                            allResults.push(...data.results.map(result => ({
                                ...result,
                                source: 'Local Search'
                            })));
                        }
                    }
                } catch (error) {
                    console.error('Local search error:', error);
                }

                // Search GitHub
                try {
                    resultsDiv.innerHTML = '<div class="loading">Searching GitHub repositories...</div>';
                    const githubData = await searchGitHub(query);
                    if (githubData && githubData.items) {
                        const githubResults = githubData.items.slice(0, 10).map(repo => ({
                            title: `${repo.name} (GitHub)`,
                            link: repo.html_url,
                            description: repo.description || 'No description available',
                            source: 'GitHub'
                        }));
                        allResults.push(...githubResults);
                    }
                } catch (error) {
                    console.error('GitHub search error:', error);
                }

                // Search Reddit
                try {
                    resultsDiv.innerHTML = '<div class="loading">Searching Reddit posts...</div>';
                    const redditData = await searchReddit(query);
                    console.log('Reddit data received:', redditData);
                    
                    if (redditData && redditData.data && redditData.data.children && redditData.data.children.length > 0) {
                        const redditResults = redditData.data.children
                            .filter(post => post.data && post.data.title)
                            .slice(0, 10)
                            .map(post => {
                                const postData = post.data;
                                return {
                                    title: `${postData.title} (Reddit)`,
                                    link: postData.url.startsWith('http') ? postData.url : `https://reddit.com${postData.permalink}`,
                                    description: postData.selftext ? 
                                        (postData.selftext.length > 200 ? postData.selftext.substring(0, 200) + '...' : postData.selftext) :
                                        `Posted in r/${postData.subreddit} ‚Ä¢ Score: ${postData.score} ‚Ä¢ ${postData.num_comments} comments`,
                                    source: 'Reddit'
                                };
                            });
                        allResults.push(...redditResults);
                        console.log('Reddit results processed:', redditResults.length);
                    } else {
                        console.log('No Reddit results found or invalid data structure');
                    }
                } catch (error) {
                    console.error('Reddit search error:', error);
                    allResults.push({
                        title: 'Reddit Search (Limited)',
                        link: `https://www.reddit.com/search?q=${encodeURIComponent(query)}`,
                        description: 'Reddit search encountered issues. Click to search manually on Reddit.',
                        source: 'Reddit'
                    });
                }

                // Display all results
                displayGeneralResults(allResults);
                
            } catch (error) {
                console.error('General search error:', error);
                resultsDiv.innerHTML = '<div style="color: var(--cyber-pink); text-align: center;">Search operation failed. Check network connection.</div>';
            }
        }

        // Display general search results with source indicators
        function displayGeneralResults(results) {
            const resultsDiv = document.getElementById('results');
            
            console.log('Displaying general results:', results);
            
            if (!results || results.length === 0) {
                resultsDiv.innerHTML = '<div style="text-align: center; color: #666;">No results found across all platforms.</div>';
                return;
            }

            const getSourceColor = (source) => {
                switch(source) {
                    case 'GitHub': return 'var(--cyber-green)';
                    case 'Reddit': return 'var(--cyber-orange)';
                    case 'Local Search': return 'var(--cyber-blue)';
                    default: return 'var(--cyber-pink)';
                }
            };

            resultsDiv.innerHTML = results.map((result, index) => {
                const title = result.title || `Result ${index + 1}`;
                const link = result.link || '#';
                const description = result.description || result.snippet || 'No description available';
                const source = result.source || 'Unknown Source';
                
                return `
                    <div class="result-item">
                        <div class="result-title">${title}</div>
                        <div style="margin-bottom: 10px;">
                            <span style="color: ${getSourceColor(source)}; font-size: 0.8rem; font-weight: bold; text-transform: uppercase;">
                                ${source}
                            </span>
                        </div>
                        <a href="${link}" target="_blank" class="result-link">${link}</a>
                        <div class="result-snippet">${description}</div>
                    </div>
                `;
            }).join('');
        }


        // Real-time event discovery function
        async function discoverEventsNow() {
            const location = document.getElementById('locationInput').value.trim();
            const radius = document.getElementById('radiusInput').value || 25;
            
            if (!location) {
                alert('Please enter a location for real-time discovery');
                return;
            }

            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<div class="loading">üîç Discovering events happening now...</div>';

            try {
                const requestBody = { 
                    location, 
                    radius: parseInt(radius),
                    urgent: true 
                };

                const response = await fetch('/api/discover-events', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                displayRealTimeResults(data);
                
                // Save the discovery
                await saveEventSearch({
                    location: data.location,
                    genre: 'real-time-discovery',
                    eventType: 'immediate',
                    results: data.results
                });
                loadArchive();
            } catch (error) {
                console.error('Real-time discovery error:', error);
                resultsDiv.innerHTML = '<div style="color: var(--cyber-pink); text-align: center;">Real-time discovery failed. Check network connection.</div>';
            }
        }

        // Display enhanced search results
        function displayEnhancedResults(data) {
            const resultsDiv = document.getElementById('results');
            
            if (!data.results || data.results.length === 0) {
                resultsDiv.innerHTML = `
                    <div style="text-align: center; color: #666;">
                        <p>No events found for "${data.location}"</p>
                        <p style="font-size: 0.9rem; margin-top: 10px;">Try adjusting your search criteria or using "Discover Now" for real-time results.</p>
                    </div>`;
                return;
            }

            const header = `
                <div style="text-align: center; margin-bottom: 20px; padding: 15px; background: rgba(0, 255, 255, 0.1); border-radius: 10px;">
                    <p style="color: var(--cyber-blue); font-weight: bold;">
                        üìç Found ${data.total} events in ${data.location}
                        ${data.genre && data.genre !== 'any' ? ` ‚Ä¢ ${data.genre}` : ''}
                        ${data.eventType && data.eventType !== 'any' ? ` ‚Ä¢ ${data.eventType}` : ''}
                    </p>
                    <p style="color: #888; font-size: 0.9rem;">
                        ${data.summary ? `Immediate: ${data.summary.immediate} | Upcoming: ${data.summary.upcoming} | Platforms: ${data.summary.platforms.length}` : ''}
                    </p>
                </div>
            `;

            // Group results by urgency
            const categorizedHTML = generateCategorizedHTML(data.categorized || {}, data.results);

            resultsDiv.innerHTML = header + categorizedHTML;
        }

        // Display real-time discovery results
        function displayRealTimeResults(data) {
            const resultsDiv = document.getElementById('results');
            
            if (!data.results || data.results.length === 0) {
                resultsDiv.innerHTML = `
                    <div style="text-align: center; color: #666;">
                        <p>No immediate events found in "${data.location}"</p>
                        <p style="font-size: 0.9rem; margin-top: 10px;">Try expanding your search radius or check back later.</p>
                    </div>`;
                return;
            }

            const header = `
                <div style="text-align: center; margin-bottom: 20px; padding: 15px; background: rgba(255, 107, 0, 0.2); border-radius: 10px; border: 2px solid var(--cyber-orange);">
                    <p style="color: var(--cyber-orange); font-weight: bold; font-size: 1.1rem;">
                        üö® REAL-TIME DISCOVERY: ${data.location}
                    </p>
                    <p style="color: var(--cyber-blue);">
                        Found ${data.summary.total} events ‚Ä¢ Immediate: ${data.summary.immediate} ‚Ä¢ Tonight: ${data.summary.tonight}
                    </p>
                    <p style="color: #888; font-size: 0.9rem;">
                        Searched ${data.meta.queriesExecuted} sources ‚Ä¢ Confidence: ${(data.summary.avgConfidence * 100).toFixed(0)}%
                    </p>
                </div>
            `;

            // Group results by time relevance
            const categorizedHTML = generateRealTimeCategorizedHTML(data.categorized, data.summary);

            resultsDiv.innerHTML = header + categorizedHTML;
        }

        // Generate categorized HTML for enhanced results
        function generateCategorizedHTML(categorized, allResults) {
            let html = '';
            
            const categories = [
                { key: 'immediate', title: 'üî• Happening Now', color: 'var(--cyber-orange)' },
                { key: 'upcoming', title: '‚ö° Coming Soon', color: 'var(--cyber-pink)' },
                { key: 'general', title: 'üìÖ General Events', color: 'var(--cyber-blue)' },
                { key: 'reference', title: 'üìö Event Directories', color: 'var(--cyber-purple)' }
            ];

            // Show categorized results if available
            if (categorized && Object.keys(categorized).length > 0) {
                categories.forEach(category => {
                    const events = categorized[category.key] || [];
                    if (events.length > 0) {
                        html += `
                            <div style="margin-bottom: 25px;">
                                <h3 style="color: ${category.color}; margin-bottom: 15px; font-family: 'Orbitron', monospace; border-bottom: 2px solid ${category.color}; padding-bottom: 5px;">
                                    ${category.title} (${events.length})
                                </h3>
                                ${events.map(event => generateEventHTML(event)).join('')}
                            </div>
                        `;
                    }
                });
            } else {
                // Fallback to all results
                html = allResults.map(event => generateEventHTML(event)).join('');
            }

            return html;
        }

        // Generate real-time categorized HTML
        function generateRealTimeCategorizedHTML(categorized, summary) {
            let html = '';
            
            const categories = [
                { key: 'immediate', title: 'üö® RIGHT NOW', color: 'var(--cyber-orange)', urgent: true },
                { key: 'tonight', title: 'üåô TONIGHT', color: 'var(--cyber-pink)', urgent: true },
                { key: 'thisWeek', title: 'üìÖ THIS WEEK', color: 'var(--cyber-blue)', urgent: false },
                { key: 'ongoing', title: 'üîÑ ONGOING', color: 'var(--cyber-green)', urgent: false }
            ];

            categories.forEach(category => {
                const events = categorized[category.key] || [];
                if (events.length > 0) {
                    html += `
                        <div style="margin-bottom: 25px;">
                            <h3 style="color: ${category.color}; margin-bottom: 15px; font-family: 'Orbitron', monospace; border-bottom: 2px solid ${category.color}; padding-bottom: 5px; ${category.urgent ? 'animation: pulse 2s infinite;' : ''}">
                                ${category.title} (${events.length})
                            </h3>
                            ${events.map(event => generateEventHTML(event, category.urgent)).join('')}
                        </div>
                    `;
                }
            });

            return html;
        }

        // Generate individual event HTML
        function generateEventHTML(event, isUrgent = false) {
            const urgencyBorder = isUrgent ? '3px solid var(--cyber-orange)' : '1px solid var(--cyber-blue)';
            const urgencyGlow = isUrgent ? 'box-shadow: 0 0 15px rgba(255, 107, 0, 0.5);' : '';
            
            return `
                <div class="result-item" style="border-left: 4px solid ${getEventTypeColor(event.eventType)}; border: ${urgencyBorder}; ${urgencyGlow}">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                        <div class="result-title" style="flex: 1;">${event.title || 'Event'}</div>
                        <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                            <span style="background: ${getEventTypeColor(event.eventType)}; color: black; padding: 2px 6px; border-radius: 10px; font-size: 0.7rem; font-weight: bold;">
                                ${event.source}
                            </span>
                            <span style="background: var(--cyber-purple); color: white; padding: 2px 6px; border-radius: 10px; font-size: 0.7rem;">
                                ${event.eventType}
                            </span>
                            ${event.urgency === 'immediate' ? '<span style="background: var(--cyber-orange); color: black; padding: 2px 6px; border-radius: 10px; font-size: 0.7rem; animation: pulse 1s infinite;">NOW</span>' : ''}
                            ${event.confidence ? `<span style="background: var(--cyber-green); color: black; padding: 2px 6px; border-radius: 10px; font-size: 0.7rem;">${(event.confidence * 100).toFixed(0)}%</span>` : ''}
                        </div>
                    </div>
                    <a href="${event.url}" target="_blank" class="result-link">${event.url}</a>
                    <div class="result-snippet">${event.description}</div>
                    <div style="display: flex; gap: 15px; margin-top: 8px; font-size: 0.8rem;">
                        ${event.category ? `<span style="color: var(--cyber-green);">üìÇ ${event.category}</span>` : ''}
                        ${event.extractedDate ? `<span style="color: var(--cyber-blue);">üìÖ ${event.extractedDate}</span>` : ''}
                        ${event.extractedTime ? `<span style="color: var(--cyber-pink);">üïê ${event.extractedTime}</span>` : ''}
                        ${event.urgency ? `<span style="color: var(--cyber-orange);">‚ö° ${event.urgency}</span>` : ''}
                    </div>
                </div>
            `;
        }

        // Get color for event type
        function getEventTypeColor(type) {
            const colors = {
                'ticketed': '#ff6b00',
                'community': '#00ff41', 
                'social': '#ff0080',
                'general': '#00ffff'
            };
            return colors[type] || '#00ffff';
        }

        // Save event search
        async function saveEventSearch(searchData) {
            try {
                await fetch('/api/save-search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        query: `${searchData.location} - ${searchData.genre || 'any'} - ${searchData.eventType || 'any'}`,
                        results: searchData.results
                    })
                });
            } catch (error) {
                console.error('Failed to save search:', error);
            }
        }

        // Load nearby events using geolocation
        async function loadNearbyEvents() {
            if (!navigator.geolocation) {
                alert('Geolocation not supported by your browser');
                return;
            }

            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<div class="loading">Getting your location...</div>';

            navigator.geolocation.getCurrentPosition(async (position) => {
                const lat = position.coords.latitude;
                const lon = position.coords.longitude;
                
                // Use reverse geocoding or just use coordinates
                document.getElementById('locationInput').value = `${lat.toFixed(2)}, ${lon.toFixed(2)}`;
                
                resultsDiv.innerHTML = '<div class="loading">Finding nearby events...</div>';
                await searchEvents();
            }, (error) => {
                resultsDiv.innerHTML = '<div style="color: var(--cyber-pink); text-align: center;">Location access denied. Please enter location manually.</div>';
            });
        }

        // Legacy search function (fallback)
        async function search() {
            // Redirect to event search
            await searchEvents();
        }

        // Clear results
        function clearResults() {
            document.getElementById('results').innerHTML = '<p style="text-align: center; color: #666;">Results cleared.</p>';
            document.getElementById('locationInput').value = '';
            document.getElementById('genreSelect').value = '';
            document.getElementById('eventTypeSelect').value = '';
            document.getElementById('timeframeSelect').value = 'upcoming';
            document.getElementById('radiusInput').value = '25';
        }

        // Load archived searches
        async function loadArchive() {
            try {
                const response = await fetch('/api/searches');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const searches = await response.json();
                displayArchive(searches);
            } catch (error) {
                console.error('Archive load error:', error);
                document.getElementById('archive').innerHTML = '<p style="text-align: center; color: var(--cyber-pink);">Archive unavailable.</p>';
            }
        }

        // Display archive
        function displayArchive(searches) {
            const archiveDiv = document.getElementById('archive');
            
            if (!searches || searches.length === 0) {
                archiveDiv.innerHTML = '<p style="text-align: center; color: #666;">No archived searches...</p>';
                return;
            }

            archiveDiv.innerHTML = searches.slice(-10).reverse().map(search => `
                <div class="archive-item" onclick="loadSearch('${search.query}')">
                    <div class="archive-query">${search.query}</div>
                    <div class="archive-date">${new Date(search.timestamp).toLocaleString()}</div>
                </div>
            `).join('');
        }

        // Load search from archive
        function loadSearch(query) {
            // Parse the archived search query format: "location - genre - eventType"
            const parts = query.split(' - ');
            if (parts.length >= 1) {
                document.getElementById('locationInput').value = parts[0];
            }
            if (parts.length >= 2 && parts[1] !== 'any') {
                document.getElementById('genreSelect').value = parts[1];
            }
            if (parts.length >= 3 && parts[2] !== 'any') {
                document.getElementById('eventTypeSelect').value = parts[2];
            }
        }

        // Handle Enter key for location input
        document.getElementById('locationInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchEvents();
            }
        });

        // Handle Enter key for radius input
        document.getElementById('radiusInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchEvents();
            }
        });

        // Handle Enter key for general search inputs
        document.getElementById('searchQuery').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                generalSearch();
            }
        });

        document.getElementById('urlInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                generalSearch();
            }
        });

        // Initialize
        createParticles();
        loadArchive();
    </script>
</body>
</html>